# 第 19 章：モジュールとパッケージ管理

## この章のゴール
- `mod` キーワードを使ってコードをモジュールに分割し、階層構造を構築できる。
- `use` キーワードを使って、他のモジュールからアイテムをスコープに取り込むことができる。
- `pub` キーワードを使って、モジュールのどの部分を公開するかを制御できる。
- クレート、パッケージ、モジュールの違いを説明できる。
- `cargo` を使って外部クレートを依存関係に追加し、利用できる。

## 前章の復習
前の章では、内部可変性について学び、`RefCell` や `Mutex` を使って、不変参照の裏で安全にデータを変更する方法を習得しました。

## なぜこれが必要なのか？
プロジェクトが成長するにつれて、すべてのコードを一つのファイルに記述するのは非現実的になります。コードを論理的な単位に分割し、整理することで、可読性、保守性、再利用性が向上します。Rust は、このための強力なモジュールシステムと、`cargo` を中心としたエコシステムを提供しています。

## Rust のエコシステム
### パッケージ (Package)
- 1つ以上のクレートを含む、ビルド、テスト、共有のための単位。
- `Cargo.toml` ファイルを持つものがパッケージです。
- 0個または1個のライブラリクレートと、任意の個数のバイナリクレートを含むことができます。

### クレート (Crate)
- ライブラリまたは実行可能ファイルを生成するための、コンパイルの最小単位。
- **ライブラリクレート:** 他のプログラムから利用されることを目的としたコードの集まり (`src/lib.rs` がルート)。
- **バイナリクレート:** 実行可能なプログラム (`src/main.rs` がルート)。

### モジュール (Module)
- クレート内のコードを整理し、名前空間を分割し、実装の詳細をカプセル化するための仕組み。

## モジュールによるコードの分割
`mod` キーワードを使ってモジュールを定義します。
```rust
// src/lib.rs
mod front_of_house {
    pub mod hosting { // hosting を公開
        pub fn add_to_waitlist() {} // この関数を公開
    }
}

pub fn eat_at_restaurant() {
    // 絶対パスで呼び出し
    crate::front_of_house::hosting::add_to_waitlist();

    // 相対パスで呼び出し
    front_of_house::hosting::add_to_waitlist();
}
```
- `crate` はクレートのルートを指すキーワードです。
- デフォルトでは、モジュール内のアイテムはすべてプライベートです。`pub` キーワードを使って、親モジュールからアクセスできるように明示的に公開する必要があります。

### `use` キーワードによるスコープへの導入
毎回長いパスを書くのは大変です。`use` キーワードを使うと、アイテムを現在のスコープに持ち込んで、短い名前で使えるようになります。
```rust
use crate::front_of_house::hosting;
// use self::front_of_house::hosting; // 相対パスでも OK

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
```
**イディオム:**
- 関数を `use` する場合: 親モジュールまでを `use` し、関数呼び出し時に親モジュール名を指定するのが一般的です。（例: `hosting::add_to_waitlist()`）
- 構造体や列挙型を `use` する場合: 型そのものまで `use` するのが一般的です。（例: `use std::collections::HashMap;`）

### ファイルへのモジュールの分割
モジュールの内容が大きくなってきたら、別のファイルに分割することができます。
1.  **`mod garden;` の場合**
    - `src/garden.rs`
    - `src/garden/mod.rs` （古い形式）
    のどちらかに、`garden` モジュールの内容を記述します。

```rust
// src/lib.rs
pub mod garden;

// src/garden.rs
pub mod vegetables;

// src/garden/vegetables.rs
// ...
```

## 外部パッケージの利用
`crates.io` は Rust の公式パッケージレジストリです。使いたいライブラリ（クレート）を見つけたら、`Cargo.toml` に追加します。
```toml
# Cargo.toml
[dependencies]
rand = "0.8.5"
```
`cargo build` を実行すると、Cargo が自動的に `rand` クレートとその依存関係をダウンロードし、コンパイルします。

コード内で使うには、`use` キーワードでクレート名を指定します。
```rust
use rand::Rng;

fn main() {
    let mut rng = rand::thread_rng();
    let n: u32 = rng.gen_range(1..=100);
    println!("Random number: {}", n);
}
```

## よくあるエラーと対処法
### エラー 1: `use of undeclared crate or module`
**原因:** `use` しようとしているモジュールやクレートが見つかりません。
**解決法:**
1.  **外部クレートの場合:** `Cargo.toml` の `[dependencies]` セクションに正しく追加されているか確認してください。
2.  **内部モジュールの場合:** `mod` 宣言が正しい場所にあるか、ファイル名やディレクトリ構造が Rust の命名規則に従っているか確認してください。

## この章のまとめ
- パッケージ > クレート > モジュール という階層構造でコードが管理される。
- `mod` でモジュールを定義し、`pub` でインターフェースを公開する。
- `use` で他のモジュールのアイテムをスコープに導入する。
- `Cargo.toml` に依存関係を記述することで、`crates.io` から簡単に外部パッケージを利用できる。

## 次の章へ
コードの構造化ができるようになりました。しかし、コードが正しい振る舞いをすることを保証するにはどうすればよいでしょうか？ 次の章では、Rust に組み込まれたテスト機能を使って、コードの品質と信頼性を高めるためのテストの書き方について学びます。
