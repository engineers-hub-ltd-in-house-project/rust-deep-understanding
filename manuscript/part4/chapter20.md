# 第 20 章：テストの書き方

## この章のゴール
- `#[test]` 属性を使って単体テストを記述できる。
- `assert!`, `assert_eq!`, `assert_ne!` マクロを使ってテストのアサーションを行える。
- `#[should_panic]` 属性を使って、パニックすべきコードが正しくパニックすることをテストできる。
- `cargo test` コマンドの基本的な使い方を理解する。
- モジュールを使ったテストの構成方法（`#[cfg(test)]`）を理解する。
- 統合テストとドキュメンテーションテストの基本的な書き方を知る。

## 前章の復習
前の章では、モジュールとパッケージ管理について学びました。コードを論理的な単位に分割し、外部のライブラリを利用する方法を習得しました。

## なぜこれが必要なのか？
プログラムの変更やリファクタリングを行う際、「この変更で既存の機能が壊れていないか？」という不安が常につきまといます。テストは、コードが期待通りに動作することを自動的に検証する仕組みです。Rust は、言語とツールチェーン（Cargo）に強力なテスト機能を組み込んでおり、高品質で信頼性の高いソフトウェアを開発する上で不可欠な要素となっています。

## 単体テスト (Unit Tests)
単体テストは、個々のモジュールや関数を隔離された環境でテストするものです。通常、テスト対象のコードと同じファイル内の `tests` という名前のサブモジュールに記述されます。

### テスト関数の書き方
1.  `tests` モジュールに `#[cfg(test)]` 属性をつけます。これにより、このモジュールは `cargo test` を実行した時にのみコンパイル・実行されるようになります。
2.  テスト関数に `#[test]` 属性をつけます。
3.  テスト関数の中で `assert!` 系のマクロを使い、期待する結果と実際の値が一致するかを検証します。

```rust
// src/lib.rs
pub fn add(left: usize, right: usize) -> usize {
    left + right
}

// テストモジュール
#[cfg(test)]
mod tests {
    use super::*; // 親モジュール (src/lib.rs) のアイテムをインポート

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4); // result が 4 と等しいことを表明
    }

    #[test]
    fn another() {
        // ここでテストに失敗するとパニックする
        // assert!(1 == 2, "This is a custom failure message");
    }
}
```

### `cargo test` の実行
プロジェクトのルートディレクトリで `cargo test` を実行すると、Cargo は `#[test]` 属性のついたすべての関数を探し出し、それぞれを新しいスレッドで並列に実行し、結果を報告します。

### パニックのテスト
ある条件下でコードが正しく `panic!` することを確認したい場合があります。その場合は `#[should_panic]` 属性を使います。
```rust
pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -> Guess {
        if value < 1 || value > 100 {
            panic!("Guess value must be between 1 and 100, got {}.", value);
        }
        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn greater_than_100() {
        Guess::new(200);
    }
}
```
このテストは、`Guess::new(200)` がパニックすれば成功し、パニックしなければ失敗します。

## 統合テスト (Integration Tests)
統合テストは、ライブラリクレートの外部から、公開された API のみをテストするものです。これにより、ライブラリの利用者が実際にどのようにコードを使うかをシミュレートできます。
- プロジェクトのルートに `tests` ディレクトリを作成します。
- `tests` ディレクトリ内の各 `.rs` ファイルは、それぞれ別のクレートとしてコンパイルされます。
- `use your_crate_name::*` のようにして、テスト対象のライブラリをインポートします。

```rust
// tests/integration_test.rs

use my_project; // ライブラリクレートの名前 (my_project) をインポート

#[test]
fn it_adds_two() {
    assert_eq!(4, my_project::add_two(2));
}
```

## ドキュメンテーションテスト
Rust の素晴らしい機能の一つが、ドキュメント内のコード例をテストとして実行できることです。これにより、ドキュメントが常に最新で、かつ動作することが保証されます。
- `///` で始まるドキュメントコメント内に、```rust ... ``` のコードブロックを記述します。
- `cargo test` を実行すると、これらのコード例もテストされます。

```rust
// src/lib.rs
/// Adds two to the given number.
///
/// # Examples
///
/// ```
/// let arg = 5;
/// let answer = my_project::add_two(arg);
///
/// assert_eq!(7, answer);
/// ```
pub fn add_two(x: i32) -> i32 {
    x + 2
}
```

## よくあるエラーと対処法
### エラー 1: テスト実行時に `unresolved import`
**原因:** テストモジュール内で、親モジュールのアイテム（関数や構造体）にアクセスしようとしたが、`use super::*;` などでスコープに導入されていません。
**解決法:** テストモジュールの先頭に `use super::*;` を追加してください。

## この章のまとめ
- 単体テストは `#[cfg(test)]` をつけた `tests` モジュール内に `#[test]` 関数として記述する。
- `assert_eq!` や `assert!` マクロで結果を検証する。
- `#[should_panic]` で意図したパニックをテストできる。
- `cargo test` は単体、統合、ドキュメンテーションテストをすべて実行する。
- 統合テストは `tests` ディレクトリに配置し、ライブラリの公開 API をテストする。

## 次の章へ
テストによってコードの正しさを保証する方法を学びました。コードの品質をさらに高めるためには、他の開発者がコードを理解しやすくするためのドキュメントや、コミュニティで共有されているベストプラクティスに従うことが重要です。次の章では、効果的なドキュメントの書き方と、一般的なコーディングスタイルについて学びます。

