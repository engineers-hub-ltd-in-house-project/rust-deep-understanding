# 第 3 章：変数と型システム

## この章のゴール
- `let` と `mut` を使った変数の宣言と、不変性 (Immutability) の重要性を理解する。
- Rust の基本的なスカラ型 (整数、浮動小数点数、論理値、文字) を使いこなせる。
- 型推論と型アノテーションの違いを理解し、適切に使い分けられる。
- シャドーイングの概念と、通常の変数再代入との違いを説明できる。

---

## 3.1 Python/Go ではこうやっていた

Python や Go では、変数の扱いは比較的シンプルでした。

- **Python**: 変数は動的型付けで、いつでも好きな値を再代入できました。型ヒントで型を明示することはできましたが、これはあくまでヒントであり、強制力はありませんでした。
  ```python
  x = 10      # 整数
  x = "hello" # 文字列を再代入できる
  ```
- **Go**: `:=` 演算子による型推論を伴う初期化や、`var` キーワードによる明示的な型宣言がありました。一度宣言した変数の型は変更できませんが、値の再代入は可能でした。
  ```go
  x := 10 // x は int 型
  x = 20  // 再代入は OK
  // x = "hello" // コンパイルエラー
  ```

## 3.2 Rust の哲学：デフォルトで不変 (Immutable by Default)

Rust の変数に関する最も大きな特徴は、デフォルトで不変 (Immutable) であることです。これは、安全性を最優先する Rust の設計思想の表れです。

```rust
fn main() {
    let x = 5;
    println!("The value of x is: {}", x);
    x = 6; // <-- コンパイルエラー！
    println!("The value of x is: {}", x);
}
```

このコードをコンパイルしようとすると、コンパイラは `cannot assign twice to immutable variable x` というエラーを出力します。一度値に束縛された不変変数を変更しようとしたためです。

なぜ不変性がデフォルトなのか？
大規模なコードベースや並行処理において、意図しない場所で変数の値が変更されてしまうことは、追跡が困難なバグの温床となります。Rust は、変数をデフォルトで不変にすることで、「値が変更される可能性がある場所」をプログラマに明示的に意識させ、コードの可読性と安全性を高めているのです。

値の変更を許可したい場合は、`mut` キーワードを使って変数を 可変 (Mutable) にする必要があります。

```rust
fn main() {
    let mut x = 5; // mut キーワードを追加
    println!("The value of x is: {}", x);
    x = 6; // OK!
    println!("The value of x is: {}", x);
}
```

この「オプトイン (明示的に選択する)」方式により、コードを読む人は `mut` という印がついている変数だけを注意すればよくなります。

```mermaid
graph TD
    subgraph "変数宣言"
        A(let x = 5) --> B{不変<br>Immutable};
        C(let mut y = 10) --> D{可変<br>Mutable};
    end

    subgraph "操作"
        B --> E[x = 6<br>❌ コンパイルエラー];
        D --> F[y = 20<br>✅ OK];
    end
```

## 3.3 基本的なスカラ型

Rust は静的型付け言語であり、コンパイル時にすべての変数の型がわかっている必要があります。Rust には 4 つの主要なスカラ型があります。

- 整数型:
  - 符号付き: `i8`, `i16`, `i32`, `i64`, `i128`, `isize` (アーキテクチャ依存)
  - 符号なし: `u8`, `u16`, `u32`, `u64`, `u128`, `usize` (アーキテクチャ依存)
  - デフォルトは `i32` です。
- 浮動小数点数型:
  - `f32` (単精度), `f64` (倍精度)
  - デフォルトは `f64` です。
- 論理値型:
  - `bool` (`true` または `false`)
- 文字型:
  - `char` (4 バイトの Unicode スカラ値)

Python や Go と違い、Rust は 暗黙的な型変換を行いません。

```rust
fn main() {
    let x: i32 = 10;
    let y: i64 = 20;
    // if x == y { } // コンパイルエラー！ 型が違うため比較できない
}
```

これにより、意図しない型変換によるバグを防いでいます。

## 3.4 型推論と型アノテーション

多くの場合、コンパイラは初期値から変数の型を推論できるため、型を明示的に書く必要はありません。

```rust
fn main() {
    let x = 2.0; // コンパイラは f64 と推論
    let y: f32 = 3.0; // 型を明示的に指定 (型アノテーション)
}
```

しかし、コンパイラが型を判断できない場合や、特定の型を強制したい場合には、型アノテーション (`: 型名`) を使います。

```rust
fn main() {
    // 文字列から数値への変換など、複数の型になりうる場合
    let guess: u32 = "42".parse().expect("Not a number!");
}
```

この例では、`.parse()` は様々な数値型に変換できる可能性があるため、`u32` 型であることを明示的に指定しています。

## 3.5 シャドーイング (Shadowing)

Rust には、シャドーイング というユニークな機能があります。これは、同じスコープ内で同じ変数名を再宣言することを許可するものです。

```rust
fn main() {
    let x = 5;

    let x = x + 1; // ここで x をシャドーイング

    {
        let x = x * 2; // 内側のスコープでさらにシャドーイング
        println!("The value of x in the inner scope is: {}", x); // => 12
    }

    println!("The value of x is: {}", x); // => 6
}
```

`mut` を使った変数の再代入との主な違いは以下の通りです。

- 型の変更が可能: シャドーイングでは、新しい変数を宣言しているため、型を変更することができます。
- 不変性の維持: シャドーイング後の変数も、`mut` を付けない限り不変です。

```rust
// 型を変更する例
let spaces = "   ";
let spaces = spaces.len(); // "spaces" は文字列から数値になる
```

この機能は、値の変換を行う際に一時的な変数名 (例: `spaces_str`, `spaces_num`) を作らずに済み、コードを簡潔に保つのに役立ちます。

## 3.6 まとめ

- ✓ Rust の変数はデフォルトで 不変。変更するには `mut` キーワードが必要。
- ✓ Rust は強い静的型付け言語で、`i32`, `f64`, `bool`, `char` などの基本型がある。
- ✓ コンパイラは型を推論できるが、必要に応じて 型アノテーション で明示的に指定する。
- ✓ シャドーイング を使うと、同じ変数名で再宣言でき、型を変更することも可能。

---

不変性という概念に最初は戸惑うかもしれませんが、これが Rust の安全性を支える重要な柱の一つです。この章で学んだ変数の基本は、今後のすべての章の基礎となります。

次の章では、これらの変数を使ってプログラムの流れを制御する「制御構文」について学びます。

