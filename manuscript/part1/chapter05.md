# 第 5 章：関数とクロージャ

## この章のゴール
- `fn` キーワードを使って関数を定義し、引数と戻り値の型を正しく指定できる。
- 文 (Statement) と式 (Expression) の違いを明確に説明できる。
- `return` キーワードの明示的な使用と、式としての暗黙的な戻り値の使い分けを理解する (本書の方針も含む)。
- クロージャの基本的な構文と、環境の変数をキャプチャする能力を理解する。

---

## 5.1 Python/Go ではこうやっていた

Python や Go でも、関数はコードをまとめる基本的な単位でした。

- Python: `def` キーワードで関数を定義し、型ヒントで引数と戻り値の型を示すことができました。`lambda` 式で簡単な無名関数も作成できました。
- Go: `func` キーワードで関数を定義し、引数と戻り値の型は常に明示する必要がありました。Go も無名関数をサポートしています。

Rust の関数定義は Go に似ていますが、式指向の性質から、値の返し方にユニークな特徴があります。

## 5.2 関数の定義と呼び出し

Rust では `fn` キーワードを使って関数を定義します。引数の型と戻り値の型は、必ず明記する必要があります。

```rust
fn main() {
    another_function(5, 'h');
}

// 関数の定義
fn another_function(x: i32, unit_label: char) {
    println!("The measurement is: {}{}", x, unit_label);
}
```

関数名の命名規則は、変数名と同様に スネークケース (`snake_case`) が慣習です。

## 5.3 文 (Statement) と式 (Expression) の違いを体験する

この違いを理解することは、Rust の戻り値、ひいては Rust 全体を理解する上で非常に重要です。

- **文 (Statement)**: 何らかのアクションを実行しますが、値を返しません。`let x = 5;` は文です。文の終わりにはセミコロン `;` が付きます。
- **式 (Expression)**: 値に評価され、結果を返します。`5 + 6` は `11` という値を返す式です。式の終わりには、通常セミコロンは付きません (文の一部にする場合を除く)。

### 試してみよう：セミコロンの有無

`cargo new functions` で新しいプロジェクトを作り、`src/main.rs` でこの違いを体験してみましょう。

```rust
fn main() {
    let y = {
        let x = 3;
        x + 1 // ここにセミコロンがないことに注目！
    };

    println!("The value of y is: {}", y);
}
```

これを `cargo run` すると、`The value of y is: 4` と表示されます。`{}` で囲まれたブロック全体が一つの式として評価され、その中の最後の式 `x + 1` の結果である `4` が `y` に束縛されました。

では、`x + 1` の後ろにセミコロンを付けてみたらどうなるでしょうか？

```rust
fn main() {
    let y = {
        let x = 3;
        x + 1; // セミコロンを追加！
    };

    println!("The value of y is: {}", y);
}
```

今度はコンパイルエラーです！

```text
error[E0308]: mismatched types
 --> src/main.rs:2:13
  |
2 |     let y = {
  |  ___________^
3 | |         let x = 3;
4 | |         x + 1;
5 | |     };
  | |_____^ expected `()`, found integer
  |
  = note: expected type `()`
             found type `{integer}`
```

`expected ()` というのは、「値が存在しないこと」を期待していた、という意味です。`x + 1` の後ろにセミコロンを付けたことで、`x + 1` は値を返す「式」から、値を返さない「文」に変わってしまいました。そのため、ブロック全体が返す値がなくなり、`y` に何も代入できなくなったのです。

この「セミコロンの有無で式の評価が変わる」という性質が、Rust の関数の戻り値の仕組みと深く関わっています。

## 5.4 関数の戻り値

Rust の関数は、`->` の後に型を記述することで戻り値を指定できます。そして、値を返す方法は 2 つあります。

### 1. `return` キーワード (本書・第 1 部での推奨)

他の多くの言語と同様に、`return` キーワードを使って明示的に値を返すことができます。これは最も直感的で分かりやすい方法です。

```rust
fn five() -> i32 {
    return 5;
}

fn main() {
    let x = five();
    println!("The value of x is: {}", x);
}
```

**本書の方針**: 企画書で述べた通り、本書の第 1 部 (第 1 章〜第 14 章) では、学習者の混乱を避けるために、常に関数の戻り値には `return` を明示的に使用します。これにより、他の言語の経験者が持つ「値を返すには `return` を書く」という直感と一致させ、学習をスムーズに進めます。

### 2. 関数の本体を「式」にする (暗黙の戻り値)

先ほど体験したように、セミコロンで終わらない式は値を返します。関数の本体全体を一つの式にすることで、その結果を暗黙的な戻り値とすることができます。

#### 試してみよう：`return` をなくしてみる

以下の `plus_one` 関数は、`return` を使わずに値を返します。`src/main.rs` で試してみましょう。

```rust
fn plus_one(x: i32) -> i32 {
    x + 1 // セミコロンなし。これが式となり、この関数の戻り値になる
}

fn main() {
    let result = plus_one(5);
    println!("The result is: {}", result); // => 6
}
```

この書き方は非常に簡潔で、Rust に慣れたプログラマは多用します。しかし、もし `x + 1` の後ろにセミコロンを付けてしまうと、先ほどと同じようにコンパイルエラーになります。

この慣用的な書き方については、基礎が固まった後の第 2 部で詳しく解説しますので、今は「こういう仕組みもあるんだな」と理解するだけで十分です。

## 5.5 クロージャ：環境をキャプチャする無名関数

クロージャは、変数に束縛できる無名関数です。定義された環境にある変数を キャプチャ して、後から使うことができるという強力な特徴があります。

```rust
fn main() {
    let x = 4;

    // `x` をキャプチャするクロージャを定義
    // 引数は `|` で囲み、型は推論されることが多い
    let equal_to_x = |z| z == x;

    let y = 4;

    assert!(equal_to_x(y));
}
```

この例では、クロージャ `equal_to_x` が、自身のスコープの外にある変数 `x` の値を「覚えて」います。

### 試してみよう：クロージャに所有権をムーブさせる

クロージャが外部の変数をどう扱うかは、所有権と深く関わっています。`move` キーワードを使うと、変数の所有権をクロージャ内に強制的に移動させることができます。

```rust
fn main() {
    let x = vec![1, 2, 3];

    // `move` を使って `x` の所有権をクロージャに移動させる
    let equal_to_x = move |z| z == x;

    // `x` はすでにクロージャに所有権を奪われているので、ここではもう使えない
    // println!("can't use x here: {:?}", x); // この行のコメントを外すとコンパイルエラー

    let y = vec![1, 2, 3];

    assert!(equal_to_x(y));
}
```

`println!` の行のコメントを外して `cargo run` すると、「`borrow of moved value: x` (ムーブされた値 `x` を借用しようとした)」という、所有権に関するエラーが発生します。

Python の `lambda` や Go の無名関数と似ていますが、Rust のクロージャは、このように所有権システムと密接に連携することで、より高い安全性を実現しています。クロージャと所有権の詳しい関係については、後の章で詳しく学びます。

## 5.6 まとめ

- ✓ 関数は `fn` で定義し、引数と戻り値の 型は必ず明記する。
- ✓ 式 は値を返し、文 は返さない。式の末尾にセミコロンを付けると文になる。
- ✓ 関数の戻り値は、`return` で明示的に返す方法と、最後の式で暗黙的に返す方法がある。
- ✓ 本書の方針: 第 1 部では、常に `return` を明示的に使用して分かりやすさを優先する。
- ✓ クロージャ は環境の変数をキャプチャできる無名関数。

---

文と式の違い、そして戻り値の扱いは、Rust のコードを読み書きする上での基本となります。特に `return` の省略は、慣れるまでは意識的に避けるのが懸命です。

次の章では、いよいよ Rust の核心であり、多くの初学者が壁と感じる「所有権」について、その仕組みを一つずつ丁寧に解き明かしていきます。
