# 第 5 章：関数とクロージャ

## この章のゴール
- `fn` キーワードを使って関数を定義し、引数と戻り値の型を正しく指定できる。
- 文 (Statement) と式 (Expression) の違いを明確に説明できる。
- `return` キーワードの明示的な使用と、式としての暗黙的な戻り値の使い分けを理解する (本書の方針も含む)。
- クロージャの基本的な構文と、環境の変数をキャプチャする能力を理解する。

---

## 5.1 Python/Go ではこうやっていた

Python や Go でも、関数はコードをまとめる基本的な単位でした。

- Python: `def` キーワードで関数を定義し、型ヒントで引数と戻り値の型を示すことができました。`lambda` 式で簡単な無名関数も作成できました。
- Go: `func` キーワードで関数を定義し、引数と戻り値の型は常に明示する必要がありました。Go も無名関数をサポートしています。

Rust の関数定義は Go に似ていますが、式指向の性質から、値の返し方にユニークな特徴があります。

## 5.2 関数の定義と呼び出し

Rust では `fn` キーワードを使って関数を定義します。引数の型と戻り値の型は、必ず明記する必要があります。

```rust
fn main() {
    another_function(5, 'h');
}

// 関数の定義
fn another_function(x: i32, unit_label: char) {
    println!("The measurement is: {}{}", x, unit_label);
}
```
[Rust Playgroundで試す](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&code=fn%20main%28%29%20%7B%0A%20%20%20%20another_function%285%2C%20%27h%27%29%3B%0A%7D%0A%0A//%20%E9%96%A2%E6%95%B0%E3%81%AE%E5%AE%9A%E7%BE%A9%0Afn%20another_function%28x%3A%20i32%2C%20unit_label%3A%20char%29%20%7B%0A%20%20%20%20println%21%28%22The%20measurement%20is%3A%20%7B%7D%7B%7D%22%2C%20x%2C%20unit_label%29%3B%0A%7D)

関数名の命名規則は、変数名と同様に スネークケース (`snake_case`) が慣習です。

## 5.3 文 (Statement) と式 (Expression) の違いを体験する

この違いを理解することは、Rust の戻り値、ひいては Rust 全体を理解する上で非常に重要です。

- **文 (Statement)**: 何らかのアクションを実行しますが、値を返しません。`let x = 5;` は文です。文の終わりにはセミコロン `;` が付きます。
- **式 (Expression)**: 値に評価され、結果を返します。`5 + 6` は `11` という値を返す式です。式の終わりには、通常セミコロンは付きません (文の一部にする場合を除く)。

### 試してみよう：セミコロンの有無

`cargo new functions` で新しいプロジェクトを作り、`src/main.rs` でこの違いを体験してみましょう。

```rust
fn main() {
    let y = {
        let x = 3;
        x + 1 // ここにセミコロンがないことに注目！
    };

    println!("The value of y is: {}", y);
}
```
[Rust Playgroundで試す](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&code=fn%20main%28%29%20%7B%0A%20%20%20%20let%20y%20%3D%20%7B%0A%20%20%20%20%20%20%20%20let%20x%20%3D%203%3B%0A%20%20%20%20%20%20%20%20x%20%2B%201%20//%20%E3%81%93%E3%81%93%E3%81%AB%E3%82%BB%E3%83%9F%E3%82%B3%E3%83%AD%E3%83%B3%E3%81%8C%E3%81%AA%E3%81%84%E3%81%93%E3%81%A8%E3%81%AB%E6%B3%A8%E7%9B%AE%EF%BC%81%0A%20%20%20%20%7D%3B%0A%0A%20%20%20%20println%21%28%22The%20value%20of%20y%20is%3A%20%7B%7D%22%2C%20y%29%3B%0A%7D)

これを `cargo run` すると、`The value of y is: 4` と表示されます。`{}` で囲まれたブロック全体が一つの式として評価され、その中の最後の式 `x + 1` の結果である `4` が `y` に束縛されました。

では、`x + 1` の後ろにセミコロンを付けてみたらどうなるでしょうか？

```rust
fn main() {
    let y = {
        let x = 3;
        x + 1; // セミコロンを追加！
    };

    println!("The value of y is: {}", y);
}
```
[Rust Playgroundで試す](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&code=fn%20main%28%29%20%7B%0A%20%20%20%20let%20y%20%3D%20%7B%0A%20%20%20%20%20%20%20%20let%20x%20%3D%203%3B%0A%20%20%20%20%20%20%20%20x%20%2B%201%3B%20//%20%E3%82%BB%E3%83%9F%E3%82%B3%E3%83%AD%E3%83%B3%E3%82%92%E8%BF%BD%E5%8A%A0%EF%BC%81%0A%20%20%20%20%7D%3B%0A%0A%20%20%20%20println%21%28%22The%20value%20of%20y%20is%3A%20%7B%7D%22%2C%20y%29%3B%0A%7D)

今度はコンパイルエラーです！

```text
error[E0308]: mismatched types
 --> src/main.rs:2:13
  |
2 |     let y = {
  |  ___________^
3 | |         let x = 3;
4 | |         x + 1;
5 | |     };
  | |_____^ expected `()`, found integer
  |
  = note: expected type `()`
             found type `{integer}`
```

`expected ()` というのは、「値が存在しないこと」を期待していた、という意味です。`x + 1` の後ろにセミコロンを付けたことで、`x + 1` は値を返す「式」から、値を返さない「文」に変わってしまいました。そのため、ブロック全体が返す値がなくなり、`y` に何も代入できなくなったのです。

この「セミコロンの有無で式の評価が変わる」という性質が、Rust の関数の戻り値の仕組みと深く関わっています。

## 5.4 関数の戻り値

Rust の関数は、`->` の後に型を記述することで戻り値を指定できます。そして、値を返す方法は 2 つあります。

### 1. `return` キーワード (本書・第 1 部での推奨)

他の多くの言語と同様に、`return` キーワードを使って明示的に値を返すことができます。これは最も直感的で分かりやすい方法です。

```rust
fn five() -> i32 {
    return 5;
}

fn main() {
    let x = five();
    println!("The value of x is: {}", x);
}
```
[Rust Playgroundで試す](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&code=fn%20five%28%29%20-%3E%20i32%20%7B%0A%20%20%20%20return%205%3B%0A%7D%0A%0Afn%20main%28%29%20%7B%0A%20%20%20%20let%20x%20%3D%20five%28%29%3B%0A%20%20%20%20println%21%28%22The%20value%20of%20x%20is%3A%20%7B%7D%22%2C%20x%29%3B%0A%7D)

**本書の方針**: 企画書で述べた通り、本書の第 1 部 (第 1 章〜第 14 章) では、学習者の混乱を避けるために、常に関数の戻り値には `return` を明示的に使用します。これにより、他の言語の経験者が持つ「値を返すには `return` を書く」という直感と一致させ、学習をスムーズに進めます。

### 2. 関数の本体を「式」にする (暗黙の戻り値)

先ほど体験したように、セミコロンで終わらない式は値を返します。関数の本体全体を一つの式にすることで、その結果を暗黙的な戻り値とすることができます。

#### 試してみよう：`return` をなくしてみる

以下の `plus_one` 関数は、`return` を使わずに値を返します。`src/main.rs` で試してみましょう。

```rust
fn plus_one(x: i32) -> i32 {
    x + 1 // セミコロンなし。これが式となり、この関数の戻り値になる
}

fn main() {
    let result = plus_one(5);
    println!("The result is: {}", result); // => 6
}
```
[Rust Playgroundで試す](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&code=fn%20plus_one%28x%3A%20i32%29%20-%3E%20i32%20%7B%0A%20%20%20%20x%20%2B%201%20//%20%E3%82%BB%E3%83%9F%E3%82%B3%E3%83%AD%E3%83%B3%E3%81%AA%E3%81%97%E3%80%82%E3%81%93%E3%82%8C%E3%81%8C%E5%BC%8F%E3%81%A8%E3%81%AA%E3%82%8A%E3%80%81%E3%81%93%E3%81%AE%E9%96%A2%E6%95%B0%E3%81%AE%E6%88%BB%E3%82%8A%E5%80%A4%E3%81%AB%E3%81%AA%E3%82%8B%0A%7D%0A%0Afn%20main%28%29%20%7B%0A%20%20%20%20let%20result%20%3D%20plus_one%285%29%3B%0A%20%20%20%20println%21%28%22The%20result%20is%3A%20%7B%7D%22%2C%20result%29%3B%20//%20%3D%3E%206%0A%7D)

この書き方は非常に簡潔で、Rust に慣れたプログラマは多用します。しかし、もし `x + 1` の後ろにセミコロンを付けてしまうと、先ほどと同じようにコンパイルエラーになります。

この慣用的な書き方については、基礎が固まった後の第 2 部で詳しく解説しますので、今は「こういう仕組みもあるんだな」と理解するだけで十分です。

## 5.5 クロージャ：環境をキャプチャする無名関数

クロージャは、変数に束縛できる無名関数です。定義された環境にある変数を キャプチャ して、後から使うことができるという強力な特徴があります。

```rust
fn main() {
    let x = 4;

    // `x` をキャプチャするクロージャを定義
    // 引数は `|` で囲み、型は推論されることが多い
    let equal_to_x = |z| z == x;

    let y = 4;

    assert!(equal_to_x(y));
}
```
[Rust Playgroundで試す](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&code=fn%20main%28%29%20%7B%0A%20%20%20%20let%20x%20%3D%204%3B%0A%0A%20%20%20%20//%20%60x%60%20%E3%82%92%E3%82%AD%E3%83%A3%E3%83%97%E3%83%81%E3%83%A3%E3%81%99%E3%82%8B%E3%82%AF%E3%83%AD%E3%83%BC%E3%82%B8%E3%83%A3%E3%82%92%E5%AE%9A%E7%BE%A9%0A%20%20%20%20//%20%E5%BC%95%E6%95%B0%E3%81%AF%20%60%7C%60%20%E3%81%A7%E5%9B%B2%E3%81%BF%E3%80%81%E5%9E%8B%E3%81%AF%E6%8E%A8%E8%AB%96%E3%81%95%E3%82%8C%E3%82%8B%E3%81%93%E3%81%A8%E3%81%8C%E5%A4%9A%E3%81%84%0A%20%20%20%20let%20equal_to_x%20%3D%20%7Cz%7C%20z%20%3D%3D%20x%3B%0A%0A%20%20%20%20let%20y%20%3D%204%3B%0A%0A%20%20%20%20assert%21%28equal_to_x%28y%29%29%3B%0A%7D)

この例では、クロージャ `equal_to_x` が、自身のスコープの外にある変数 `x` の値を「覚えて」います。

### 試してみよう：クロージャに所有権をムーブさせる

クロージャが外部の変数をどう扱うかは、所有権と深く関わっています。`move` キーワードを使うと、変数の所有権をクロージャ内に強制的に移動させることができます。

```rust
fn main() {
    let x = vec![1, 2, 3];

    // `move` を使って `x` の所有権をクロージャに移動させる
    let equal_to_x = move |z| z == x;

    // `x` はすでにクロージャに所有権を奪われているので、ここではもう使えない
    // println!("can't use x here: {:?}", x); // この行のコメントを外すとコンパイルエラー

    let y = vec![1, 2, 3];

    assert!(equal_to_x(y));
}
```
[Rust Playgroundで試す](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&code=fn%20main%28%29%20%7B%0A%20%20%20%20let%20x%20%3D%20vec%21%5B1%2C%202%2C%203%5D%3B%0A%0A%20%20%20%20//%20%60move%60%20%E3%82%92%E4%BD%BF%E3%81%A3%E3%81%A6%20%60x%60%20%E3%81%AE%E6%89%80%E6%9C%89%E6%A8%A9%E3%82%92%E3%82%AF%E3%83%AD%E3%83%BC%E3%82%B8%E3%83%A3%E3%81%AB%E7%A7%BB%E5%8B%95%E3%81%95%E3%81%9B%E3%82%8B%0A%20%20%20%20let%20equal_to_x%20%3D%20move%20%7Cz%7C%20z%20%3D%3D%20x%3B%0A%0A%20%20%20%20//%20%60x%60%20%E3%81%AF%E3%81%99%E3%81%A7%E3%81%AB%E3%82%AF%E3%83%AD%E3%83%BC%E3%82%B8%E3%83%A3%E3%81%AB%E6%89%80%E6%9C%89%E6%A8%A9%E3%82%92%E5%A5%AA%E3%82%8F%E3%82%8C%E3%81%A6%E3%81%84%E3%82%8B%E3%81%AE%E3%81%A7%E3%80%81%E3%81%93%E3%81%93%E3%81%A7%E3%81%AF%E3%82%82%E3%81%86%E4%BD%BF%E3%81%88%E3%81%AA%E3%81%84%0A%20%20%20%20//%20println%21%28%22can%27t%20use%20x%20here%3A%20%7B%3A%3F%7D%22%2C%20x%29%3B%20//%20%E3%81%93%E3%81%AE%E8%A1%8C%E3%81%AE%E3%82%B3%E3%83%A1%E3%83%B3%E3%83%88%E3%82%92%E5%A4%96%E3%81%99%E3%81%A8%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%AB%E3%82%A8%E3%83%A9%E3%83%BC%0A%0A%20%20%20%20let%20y%20%3D%20vec%21%5B1%2C%202%2C%203%5D%3B%0A%0A%20%20%20%20assert%21%28equal_to_x%28y%29%29%3B%0A%7D)

`println!` の行のコメントを外して `cargo run` すると、「`borrow of moved value: x` (ムーブされた値 `x` を借用しようとした)」という、所有権に関するエラーが発生します。

Python の `lambda` や Go の無名関数と似ていますが、Rust のクロージャは、このように所有権システムと密接に連携することで、より高い安全性を実現しています。クロージャと所有権の詳しい関係については、後の章で詳しく学びます。

## 5.6 まとめ

- ✓ 関数は `fn` で定義し、引数と戻り値の 型は必ず明記する。
- ✓ 式 は値を返し、文 は返さない。式の末尾にセミコロンを付けると文になる。
- ✓ 関数の戻り値は、`return` で明示的に返す方法と、最後の式で暗黙的に返す方法がある。
- ✓ 本書の方針: 第 1 部では、常に `return` を明示的に使用して分かりやすさを優先する。
- ✓ クロージャ は環境の変数をキャプチャできる無名関数。

---

文と式の違い、そして戻り値の扱いは、Rust のコードを読み書きする上での基本となります。特に `return` の省略は、慣れるまでは意識的に避けるのが懸命です。

次の章では、いよいよ Rust の核心であり、多くの初学者が壁と感じる「所有権」について、その仕組みを一つずつ丁寧に解き明かしていきます。
