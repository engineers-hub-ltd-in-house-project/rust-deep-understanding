# 第 28 章：Python/Go コードからの移行戦略

## この章のゴール
- Rust を既存の Python/Go プロジェクトに組み込むFFI (Foreign Function Interface) の基本を理解する。
- `PyO3` や `rust-cgo` といったライブラリの役割を知る。
- パフォーマンスクリティカルな部分を特定し、Rust で書き換えるアプローチを理解する。
- 全面的な書き換え（リライト）と、部分的な統合のトレードオフを検討できるようになる。
- 移行プロジェクトを計画する際のベストプラクティスを学ぶ。

## 前章の復習
前の章では、ファイル I/O とデータ処理について学びました。`serde` を使ったデータのシリアライズ・デシリアライズや、大きなデータを効率的に扱う方法を習得しました。

## なぜこれが必要なのか？
「Rust は素晴らしい、すべてのプロジェクトを Rust で書き直そう！」と考えるのは魅力的ですが、現実的ではありません。多くの組織には、長年運用されてきた Python や Go による巨大なコードベースが存在します。これらの資産を活かしつつ、Rust のパフォーマンスと安全性の恩恵を受けるには、段階的かつ戦略的なアプローチが必要です。この章では、既存のコードベースと Rust を共存させ、徐々に移行していくための戦略を探ります。

## アプローチ 1: 部分的な統合 (FFI)
最も一般的でリスクの低いアプローチは、アプリケーション全体の中で、特にパフォーマンスが要求される部分や、CPU バウンドな処理を特定し、その部分だけを Rust で書き換える方法です。これは **FFI (Foreign Function Interface)** を通じて実現されます。

### Python との連携: `PyO3`
`PyO3` は、Python から Rust の関数を呼び出したり、Rust から Python のオブジェクトを操作したりするための包括的なライブラリです。
1.  Rust でロジックを実装し、Python モジュールとして公開するためのラッパーを `PyO3` を使って記述します。
2.  `maturin` というツールを使って、Rust コードをコンパイルし、Python が `import` できる共有ライブラリ（`.so` や `.pyd`）をビルドします。
3.  Python コードからは、`pip install` でこのライブラリをインストールし、通常の Python モジュールとして `import` して使います。

```rust
// Rust 側 (lib.rs)
use pyo3::prelude::*;

/// Formats the sum of two numbers as string.
#[pyfunction]
fn sum_as_string(a: usize, b: usize) -> PyResult<String> {
    Ok((a + b).to_string())
}

/// A Python module implemented in Rust.
#[pymodule]
fn my_rust_module(_py: Python, m: &PyModule) -> PyResult<()> {
    m.add_function(wrap_pyfunction!(sum_as_string, m)?)?;
    Ok(())
}
```
```python
# Python 側
import my_rust_module

result = my_rust_module.sum_as_string(5, 10)
assert result == "15"
```
このアプローチにより、例えばデータ処理パイプラインの重い計算部分だけを Rust に置き換えて、全体のパフォーマンスを劇的に向上させることができます。

### Go との連携
Go と Rust の連携は、両者が C 言語の ABI (Application Binary Interface) を介して通信するのが一般的です。
1.  Rust 側で、C ABI と互換性のある関数 (`extern "C" fn`) をエクスポートする共有ライブラリ (`.so`, `.dll`, `.dylib`) を作成します。
2.  Go 側で、`cgo` を使ってこの共有ライブラリをインポートし、対応する Go の関数シグネチャを定義して呼び出します。

この方法は `PyO3` ほど洗練されていませんが、Go の構造体をメモリレイアウトの互換性がある C の `struct` に変換するなどして、複雑なデータも受け渡し可能です。

## アプローチ 2: 全面的なリライト
既存のサービスが技術的負債を多く抱えている、あるいは根本的にパフォーマンスや信頼性の問題を抱えている場合など、思い切って Rust で完全に書き換えるという選択肢もあります。

### リライトのメリット
- **パフォーマンスと信頼性の向上:** Rust の恩恵を最大限に享受できます。
- **技術的負債の解消:** 古い設計や依存関係を断ち切り、モダンなアーキテクチャで再構築できます。
- **メンテナンス性の向上:** 強力な型システムとツールチェーンにより、長期的なメンテナンスコストが下がる可能性があります。

### リライトのリスク
- **高コスト:** 開発には時間とリソースがかかります。
- **移行リスク:** 既存のサービスの振る舞いを完全に再現するのは難しく、バグや仕様漏れが発生する可能性があります。
- **ビジネスの停止:** リライト中は新機能の開発が停滞する可能性があります。

### ストラングラー・パターン
リスクを軽減するため、**ストラングラー（絞め殺し）パターン**が有効です。これは、新しいシステム（Rust）を既存のシステム（Python/Go）の前面にプロキシのように配置し、リクエストを一つずつ新しいシステムに流すように切り替えていく方法です。時間をかけて徐々に古いシステムを「絞め殺し」ていき、最終的に完全に置き換えます。

## 移行計画のベストプラクティス
1.  **ボトルネックの特定:** まずはプロファイリングツールを使い、どこが本当にパフォーマンスのボトルネックになっているかを正確に特定します。勘で最適化してはいけません。
2.  **小さく始める:** 最初から大きな機能を Rust で書き換えるのではなく、小さく、独立した、純粋な計算処理（副作用の少ない関数）から始めるのが得策です。
3.  **明確な境界を定義する:** Rust と他の言語との間のインターフェース（FFI の境界）を明確に定義し、データ交換のオーバーヘッドを最小限に抑えるように設計します。
4.  **テストを徹底する:** 既存のコードに十分なテストがない場合、リファクタリングや移行は非常に危険です。まず、振る舞いを保証するためのテストスイートを整備することが先決です。

## この章のまとめ
- 既存の Python/Go コードベースを Rust に移行するには、部分的な統合と全面的なリライトの2つの主要なアプローチがある。
- `PyO3` を使うと、Python と Rust をシームレスに連携させ、パフォーマンスクリティカルな部分を Rust で高速化できる。
- 全面的なリライトは高リスクだが、ストラングラー・パターンなどを活用して段階的に進めることでリスクを軽減できる。
- 成功の鍵は、ボトルネックの正確な特定、小さなステップでの開始、そして徹底したテスト。

## 次の章へ
第6部では、実践的なプロジェクトを通じて、これまでに学んだ知識を統合してきました。次の第7部では、さらに Rust の能力を深く引き出すための、より発展的なトピックを探求します。まずは、Rust のメタプログラミング機能の核である「マクロ」の基礎から始めましょう。

