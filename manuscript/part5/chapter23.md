# 第 23 章：並行処理：スレッドとメッセージパッシング

## この章のゴール
- `thread::spawn` を使って新しいスレッドを生成し、メインスレッドと並行にコードを実行できる。
- メインスレッドの変数をスレッド内で使おうとした際に発生するコンパイルエラーを、`move` キーワードを使って解決できる。
- `JoinHandle` の `.join()` メソッドを使い、すべてのスレッドが終了するのを待機できる。
- `Arc<Mutex<T>>` を使い、複数のスレッドから共有データを安全に変更できるようになる。

---

## 23.1 並行処理 vs 並列処理

- 並行 (Concurrency): 複数のタスクが 見かけ上 同時に進行している状態。実際には、単一のCPUコアがタスクを高速に切り替えながら実行しているかもしれない。
- 並列 (Parallelism): 複数のタスクが 物理的に 同時に実行されている状態。マルチコアCPUの各コアが、それぞれ別のタスクを実行する。

Rustは、OSが提供するスレッド機能を利用して、並行処理と並列処理の両方を実現します。

## 23.2 スレッドの生成：`thread::spawn`

`std::thread::spawn` 関数は、新しいOSスレッドを生成し、その上でクロージャを実行します。

```sh
cargo new threads
```
でプロジェクトを作り、スレッドの基本的な動きを見てみましょう。

### `join` ハンドルでスレッドの終了を待つ

メインスレッドが先に終了してしまうと、生成されたスレッドが処理を完了する前にプログラム全体が終了してしまう可能性があります。`spawn` が返す `JoinHandle` の `join()` メソッドを呼び出すことで、そのスレッドが終了するまでメインスレッドの実行を待機させることができます。

### `move` クロージャと所有権

スレッドにデータを渡す際、所有権の問題が発生します。`spawn` に渡すクロージャに `move` キーワードを付けることで、クロージャが使用する環境変数の所有権を強制的にクロージャ内にムーブさせることができます。

## 23.3 メッセージパッシングによるスレッド間通信

「共有メモリによる通信はするな、代わりに通信によってメモリを共有せよ」(Do not communicate by sharing memory; instead, share memory by communicating.) というのは、Go言語などの並行処理モデルで有名な考え方です。

Rustでは、チャネル (Channel) を使ってこのメッセージパッシングを実現します。チャネルは、送信側 (`Sender`) と受信側 (`Receiver`) のペアで構成されます。

## 23.4 `Mutex<T>` による共有メモリ

伝統的な並行処理モデルは、ミューテックス (Mutex: Mutual Exclusion) を使った共有メモリです。`Mutex<T>` は、一度に一つのスレッドしかデータにアクセスできないようにロックをかける仕組みを提供します。

Rustの `Mutex<T>` は、ロックの取得 (`lock()`) に失敗するとスレッドをブロックし、ロックが解放されるのを待ちます。また、`lock()` が返す `MutexGuard` というスマートポインタがスコープを抜けるときに自動的にロックを解放するため、ロックのかけ忘れによるデッドロックのリスクを低減します。

### `Arc<T>`：スレッドセーフな参照カウント

`Mutex<T>` を複数のスレッドで共有しようとすると、所有権の問題が再び発生します。`Rc<T>` はスレッドセーフではないため、コンパイルエラーになります。

`Arc<T>` (Atomic Reference Counting) は、`Rc<T>` のスレッドセーフ版です。参照カウントの増減をアトミックに行うため、複数のスレッドから安全に所有権を共有できます。

## 23.5 まとめ

- Rust は `thread::spawn` を通じて OS ネイティブのスレッドを生成し、並行・並列処理を実現する。
- スレッドの終了を待つには `JoinHandle` の `join()` メソッドを使う。
- スレッド間の通信方法には、チャネルを使った メッセージパッシング と、`Mutex` を使った 共有メモリ の2つの主要なアプローチがある。
- チャネルは送信側 `Sender` と受信側 `Receiver` からなり、所有権システムを利用して安全な通信を保証する。
- `Mutex<T>` は、データへのアクセスを一度に一つのスレッドに制限するためのロック機能を提供する。`MutexGuard` がスコープを抜けるときに自動でロックが解除される。
- `Arc<T>` は `Rc<T>` のスレッドセーフ版であり、`Mutex` と組み合わせることで、複数のスレッドから安全にデータを共有・変更する一般的なパターン (`Arc<Mutex<T>>`) を実現する。

---

これで、Rust がいかにして「恐怖なき並行性 (Fearless Concurrency)」を実現しているかの基本を学びました。次の章では、より現代的で高レベルな非同期処理の仕組みである `async`/`await` について探求します。
