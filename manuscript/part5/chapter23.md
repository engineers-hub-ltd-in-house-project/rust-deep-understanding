# 第 23 章：Async/Await の基礎

## この章のゴール
- 同期 I/O と非同期 I/O の違いを理解する。
- `async` と `.await` が Rust の非同期コードを構成する基本的な要素であることを理解する。
- フューチャー (`Future` トレイト) が非同期処理の単位であることを理解する。
- 非同期ランタイム（例: `tokio`）の役割と、なぜそれが必要なのかを説明できる。
- 簡単な非同期関数を書き、実行できるようになる。

## 前章の復習
前の章では、OS のスレッドを使った並行プログラミングについて学びました。`thread::spawn` でタスクを並列実行し、チャネルや `Mutex` を使ってスレッド間で通信・データ共有する方法を見ました。

## なぜこれが必要なのか？
Web サーバーのように、多数のクライアントと同時に通信し、ネットワークやデータベースからの応答を待つような I/O バウンドなタスクを考えてみましょう。従来のスレッドモデルでは、一つのクライアントごとに一つの OS スレッドを割り当てると、クライアント数が数百、数千と増えるにつれて、スレッドの生成コストやコンテキストスイッチのオーバーヘッドが問題になります。

**非同期プログラミング**は、この問題を解決します。単一のスレッド上で、多数のタスクを効率的に管理する仕組みです。あるタスクが I/O（例: ネットワークからのデータ受信）を待っている間、そのスレッドはブロックされず、他の実行可能なタスクを進めることができます。これにより、少ないスレッドで非常に高い並行性を実現できます。

## Python/Go ではこうやっていた
- **Python:** `asyncio` ライブラリと `async`/`await` 構文を使って非同期プログラミングを行いました。
- **Go:** ゴルーチンとチャネルが言語のコア機能として組み込まれており、非常に軽量な並行処理を直感的に記述できました。Go のモデルも内部的には非同期 I/O を利用しています。

## Rust ではこう書く: Async/Await
Rust の `async`/`await` は、構文的には Python のものと非常に似ていますが、その裏側の仕組みは異なります。

### `async` fn: 非同期関数の定義
`async` キーワードを `fn` の前につけると、その関数は非同期関数になります。非同期関数は、呼び出されてもすぐには実行されません。代わりに、「フューチャー (`Future`)」と呼ばれる、将来のある時点で完了する計算を表すオブジェクトを返します。
```rust
async fn hello_world() {
    println!("hello, world!");
}
```

### `Future` トレイト
`Future` は、非同期処理の核となるトレイトです。
```rust
trait Future {
    type Output;
    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;
}
```
`async` 関数は、この `Future` トレイトを実装した匿名の方を返すシンタックスシュガーと考えることができます。

### `.await`: フューチャーの実行を待つ
フューチャーは、それ自体では何もしません。それを実行するためには、`.await` 演算子を使います。`.await` は、フューチャーが完了するまで現在のタスクの実行を**非同期的に**待機します。つまり、待っている間、スレッドは他のタスクを実行することができます。
```rust
async fn do_something() {
    let result = some_other_async_function().await;
    // ... result を使った処理 ...
}
```
**注意:** `.await` は `async` 関数または `async` ブロックの中でしか使えません。

### 非同期ランタイム
フューチャーを実行し、どのタスクをいつ実行するかを管理するコンポーネント、それが**非同期ランタイム**です。Rust の標準ライブラリは `async`/`await` の構文と `Future` トレイトを提供するだけで、具体的なランタイムは含んでいません。

最も広く使われているランタイムには以下のようなものがあります。
- `tokio`: Web サービスやネットワークアプリケーションでデファクトスタンダード。
- `async-std`: 標準ライブラリの API を非同期版として提供することを目指す。

`tokio` を使って最初の非同期プログラムを動かしてみましょう。
```toml
# Cargo.toml
[dependencies]
tokio = { version = "1", features = ["full"] }
```

```rust
// src/main.rs
async fn say_hello() {
    println!("Hello");
}

#[tokio::main]
async fn main() {
    // say_hello() は Future を返す
    let future = say_hello();

    println!("Let's start");
    
    // .await で Future を実行する
    future.await;
}
```
`#[tokio::main]` マクロは、`main` 関数を非同期関数にし、その中で `tokio` ランタイムを起動してフューチャーを実行する定型的なコードを自動で生成してくれます。

## よくあるエラーと対処法
### エラー 1: `.await` is only allowed inside `async` functions and blocks
**原因:** `async` でない通常の関数（例えば `main` 関数）の中で `.await` を使おうとしました。
**解決法:**
1.  関数を `async fn` に変更します。
2.  `main` 関数の場合は、`#[tokio::main]` のようなランタイムのマクロを `main` 関数の前に追加します。

## この章のまとめ
- 非同期プログラミングは、I/O バウンドなタスクを少ないスレッドで効率的に扱うための技術。
- `async fn` は、実行可能な計算のレシピである `Future` を返す。
- `.await` は、`Future` が完了するのを非同期的に待機し、結果を取り出す。
- `Future` を実際に動かすためには、`tokio` のような非同期ランタイムが必要。

## 次の章へ
`async`/`await` の基本的な構文と、非同期プログラムを動かすための仕組みを理解しました。しかし、実際のアプリケーションでは、複数の非同期タスクを同時に実行したり、タイマーやネットワーク通信といった具体的な I/O 操作を行ったりする必要があります。次の章では、より実践的な非同期プログラミングのパターンについて学びます。
