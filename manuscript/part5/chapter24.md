# 第 24 章：非同期処理：`async`/`await`

## この章のゴール
- 同期処理と非同期処理の違い、特にI/Oバウンドなタスクにおける非同期処理の利点を説明できる。
- `async` ブロックや `async move` クロージャを使い、非同期なコードの断片を作成できる。
- `Future` トレイトが、非同期処理における「未来のある時点で完了する値」を表す核となる抽象化であることを理解する。

---

## 24.1 なぜ非同期処理が必要なのか？：スレッドモデルの限界

前章で学んだスレッドは、CPUバウンドなタスク（純粋な計算処理）を並列化するには非常に効果的です。しかし、ネットワーク通信やファイルI/Oのような **I/Oバウンド** なタスクでは、スレッドはリソースを効率的に使えないことがあります。

1.  **生成コスト**: OSスレッドの生成と切り替え（コンテキストスイッチ）には、CPU時間とメモリの両面で無視できないコストがかかります。
2.  **数の限界**: OSが同時に扱えるスレッドの数には上限があります。

例えば、数万のクライアントからの同時接続を処理するWebサーバーを考えてみましょう。クライアントごとに1つのOSスレッドを割り当てていては、あっという間にリソースを使い果たしてしまいます。

この問題を解決するのが非同期プログラミングです。非同期モデルでは、あるタスクがI/O（ネットワークからの応答待ちなど）でブロックされている間、CPUを他のタスクの実行に充てることができます。これにより、ごく少数のOSスレッドで、非常に多くのタスクを効率的にさばくことが可能になります。

非同期処理は、この「待機時間」を有効活用するためのプログラミングモデルです。単一のスレッド上で、あるタスクがI/Oでブロックされている間に、別のタスクを実行することができます。これにより、OSスレッドを大量に作ることなく、多数のI/Oバウンドなタスクを効率的に捌くことができます。

## 24.2 `async`/`await` の基本

Rustの非同期処理は、`async` と `await` という2つのキーワードを中心に構築されています。

- **`async`**: 関数やブロックを非同期関数としてマークします。これにより、関数は `Future` を返すことができます。
- **`.await`**: `async` 関数や `Future` の実行を待ち、完了したらその結果を返す。`.await` は `async` 関数または `async` ブロックの中でのみ使用できる。

### 試してみよう：非同期関数の定義と実行

```sh
cargo new async-basics
```
でプロジェクトを作り、非同期の基本的なコードを書いてみましょう。`async` を使うには、非同期ランタイムが必要です。ここでは、最も人気のある `tokio` を使います。

**`Cargo.toml` に `tokio` を追加**

そして、`async` 関数を定義して、普通の関数と同じように呼び出してみましょう。

```rust
// src/main.rs
async fn say_hello() {
    println!("Hello, async world!");
}

fn main() {
    println!("Let's start!");
    say_hello(); // これを呼び出しても、"Hello, async world!" は表示されない！
    println!("Finished.");
}
```
[Rust Playgroundで試す](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&code=//%20src/main.rs%0Aasync%20fn%20say_hello%28%29%20%7B%0A%20%20%20%20println%21%28%22Hello%2C%20async%20world%21%22%29%3B%0A%7D%0A%0Afn%20main%28%29%20%7B%0A%20%20%20%20println%21%28%22Let%27s%20start%21%22%29%3B%0A%20%20%20%20say_hello%28%29%3B%20//%20%E3%81%93%E3%82%8C%E3%82%92%E5%91%BC%E3%81%B3%E5%87%BA%E3%81%97%E3%81%A6%E3%82%82%E3%80%81%22Hello%2C%20async%20world%21%22%20%E3%81%AF%E8%A1%A8%E7%A4%BA%E3%81%95%E3%82%8C%E3%81%AA%E3%81%84%EF%BC%81%0A%20%20%20%20println%21%28%22Finished.%22%29%3B%0A%7D)

実行しても、コンソールには `Let's start!` と `Finished.` しか表示されません。`say_hello` が返した `Future` という「レシピ」は、誰にも実行されることなく捨てられてしまったのです。

`#[tokio::main]` は、`main` 関数を非同期関数にし、Tokioランタイム上で実行するためのマクロです。

## 24.3 `Future` トレイト

`async fn` は、実は `Future` というトレイトを実装した型を返す関数の糖衣構文です。

### 試してみよう：`async` 関数を呼び出しても何も起こらないことを体験する

```sh
cargo new async-basics
```
でプロジェクトを作り、`Cargo.toml` に `tokio` を追加します。

そして、`async` 関数を定義して、普通の関数と同じように呼び出してみましょう。

```rust
// src/main.rs
async fn say_hello() {
    println!("Hello, async world!");
}

#[tokio::main]
async fn main() { // main 関数も async fn になっていることに注意
    println!("Let's start!");
    say_hello().await; // .await で Future が完了するのを待つ
    println!("Finished.");
}
```
[Rust Playgroundで試す](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&code=//%20src/main.rs%0Aasync%20fn%20say_hello%28%29%20%7B%0A%20%20%20%20println%21%28%22Hello%2C%20async%20world%21%22%29%3B%0A%7D%0A%0A%23%5Btokio%3A%3Amain%5D%0Aasync%20fn%20main%28%29%20%7B%20//%20main%20%E9%96%A2%E6%95%B0%E3%82%82%20async%20fn%20%E3%81%AB%E3%81%AA%E3%81%A3%E3%81%A6%E3%81%84%E3%82%8B%E3%81%93%E3%81%A8%E3%81%AB%E6%B3%A8%E6%84%8F%0A%20%20%20%20println%21%28%22Let%27s%20start%21%22%29%3B%0A%20%20%20%20say_hello%28%29.await%3B%20//%20.await%20%E3%81%A7%20Future%20%E3%81%8C%E5%AE%8C%E4%BA%86%E3%81%99%E3%82%8B%E3%81%AE%E3%82%92%E5%BE%85%E3%81%A4%0A%20%20%20%20println%21%28%22Finished.%22%29%3B%0A%7D)
これを実行すると、今度は "Hello, async world!" が表示されます。

`Future` は、未来のある時点で完了する可能性のある値を表現します。非同期ランタイム（エグゼキュータ）は、この `Future` を `poll` メソッドで定期的に呼び出し、処理を進めます。

## 24.4 非同期エコシステム

Rustの非同期は、言語機能（`async`/`await`）とライブラリ（ランタイムやユーティリティ）の組み合わせで成り立っています。

- **ランタイム**: `tokio`, `async-std`, `smol` など。`Future` を実行し、I/Oイベントを管理する。
- **ユーティリティ**: `futures` クレートは、`Future` を操作するための基本的なツール（`join!`, `select!` など）を提供します。

## 24.5 まとめ

- 非同期処理は、特にネットワークサービスのようなI/Oバウンドなタスクにおいて、スレッドよりも少ないリソースで高いパフォーマンスを発揮する。
- `async fn` は、`Future` を返す非同期関数を定義する。
- `await` は、`Future` が完了するのを非ブロッキングで待ち、結果を取り出す。
- `async`/`await` を使うには、`tokio` のような非同期ランタイムが必要。
- `Future` トレイトは、非同期処理の中心的な抽象化であり、ランタイムによって `poll` されることで処理が進行する。

---

`async`/`await` は、現代的なネットワークプログラミングや並行処理において不可欠なツールです。次の章では、これまでに学んだ知識を総動員して、簡単な非同期TCPエコサーバーを実装してみましょう。