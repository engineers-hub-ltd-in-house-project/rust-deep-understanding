# 第 22 章：スレッドと並行性

## この章のゴール
- `thread::spawn` を使って新しいスレッドを生成し、コードを並行に実行できるようになる。
- `join` ハンドルを使って、スレッドが終了するのを待機できる。
- `move` クロージャを使って、スレッドにデータの所有権を渡せる。
- チャネル (`std::sync::mpsc`) を使って、スレッド間で安全にメッセージを送受信できる。
- `Arc<Mutex<T>>` を使って、複数のスレッドから共有状態を安全に変更できる（第18章の復習）。

## 前章の復習
前の章では、ドキュメントの書き方と、`rustfmt` や `clippy` といったツールを使ってコードの品質を高める方法について学びました。

## なぜこれが必要なのか？
現代のコンピュータは複数の CPU コアを持つのが当たり前になっており、これらのコアを有効活用することで、プログラムのパフォーマンスを劇的に向上させることができます。並行プログラミングは、計算量の多いタスクを複数の部分に分割し、それらを同時に実行する技術です。

しかし、並行プログラミングには特有の難しさがあります。
- **データ競合:** 複数のスレッドが同時に同じデータにアクセスし、少なくとも一つのスレッドが書き込みを行う場合に発生します。
- **デッドロック:** 複数のスレッドが、お互いが保持しているリソースを待ち続けてしまい、処理が進まなくなる状態です。

Rust は、所有権システムと型システムを通じて、これらの問題の多くを**コンパイル時**に検出することを可能にし、「恐怖なき並行性 (Fearless Concurrency)」を実現します。

## スレッドの生成
`std::thread::spawn` 関数にクロージャを渡すことで、新しいスレッドを生成できます。
```rust
use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {} from the spawned thread!", i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!("hi number {} from the main thread!", i);
        thread::sleep(Duration::from_millis(1));
    }
}
```
このコードを実行すると、メインスレッドと新しいスレッドの出力が交互に表示されるはずです。しかし、メインスレッドが先に終了してしまうと、新しいスレッドは途中で強制終了されてしまいます。

### `join` による待機
`spawn` が返す `JoinHandle` の `.join()` メソッドを呼び出すことで、そのスレッドが終了するまで現在のスレッドを待機させることができます。
```rust
let handle = thread::spawn(...);
// ... 他の処理 ...
handle.join().unwrap(); // handle のスレッドが終了するのを待つ
```

### `move` クロージャ
スレッド内でメインスレッドのデータを使いたい場合、`move` キーワードを使って、データの所有権をクロージャに移す必要があります。
```rust
let v = vec![1, 2, 3];

let handle = thread::spawn(move || {
    // v の所有権がこのクロージャに移る
    println!("Here's a vector: {:?}", v);
});

handle.join().unwrap();
```
もし `move` をつけないと、クロージャがいつまで実行されるか不明なため、メインスレッドの `v` への参照がダングリングポインタになる可能性があり、コンパイルエラーとなります。

## チャネルによるメッセージパッシング
複数のスレッドが同じメモリを共有するのではなく、スレッド間でメッセージを送り合うことで通信する方法です。Go 言語のチャネルに似た考え方です。
- `mpsc` は *multiple producer, single consumer* の略です。
- `Sender`（送信側）と `Receiver`（受信側）のペアを作成します。
- `Sender` はクローン可能なので、複数の送信スレッドを持つことができます。
- `Receiver` は一つだけです。

```rust
use std::sync::mpsc;
use std::thread;

let (tx, rx) = mpsc::channel(); // tx: sender, rx: receiver

thread::spawn(move || {
    let val = String::from("hi");
    tx.send(val).unwrap();
    // val の所有権は send によって移動する
});

let received = rx.recv().unwrap(); // 受信するまでブロックする
println!("Got: {}", received);
```

## 共有状態の並行性
チャネルが有効でない場合や、より複雑な状態共有が必要な場合は、`Mutex` を使った共有メモリモデルを利用します。第18章で学んだ `Arc<Mutex<T>>` パターンは、このための最も一般的なイディオムです。

## よくあるエラーと対処法
### エラー 1: `closure may outlive current function`
**原因:** スレッドのクロージャ内で、`move` を使わずに外部の変数を参照しようとしました。
**解決法:** クロージャの前に `move` キーワードを追加して、変数の所有権をスレッドに移してください。

## この章のまとめ
- `thread::spawn` で新しいスレッドを生成し、`.join()` でその終了を待つ。
- `move` クロージャを使って、スレッドにデータの所有権を安全に渡す。
- チャネル (`mpsc`) は、スレッド間で所有権を移動させながら安全に通信するための優れた方法。
- 複数のスレッドからデータを変更する必要がある場合は、`Arc<Mutex<T>>` を使った共有状態モデルを利用する。

## 次の章へ
OS のスレッドは強力ですが、スレッドの生成やコンテキストスイッチにはコストがかかります。数百、数千といった大量の並行タスクを効率的に扱うには、より軽量な非同期プログラミングのモデルが必要です。次の章では、Rust の `async/await` 構文を使った、モダンな非同期プログラミングの基礎について学びます。
