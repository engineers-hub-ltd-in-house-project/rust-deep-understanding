# 第 22 章：エラーハンドリング：`Result` 型と `?` 演算子

## この章のゴール
- `panic!` が回復不能なエラーに適しているのに対し、`Result` 型が回復可能なエラーに適している理由を説明できる。
- `main` 関数が `Result<(), Box<dyn Error>>` を返すことで、アプリケーションレベルのエラー伝播を簡潔に書けることを理解する。

---

## 22.1 回復不能なエラー vs 回復可能なエラー

エラーには大きく分けて2種類あります。
- 回復不能なエラー (Unrecoverable Error): メモリ不足、ディスクエラー、セキュリティ違反など、プログラムが予期せず、対処が困難なエラー。
- 回復可能なエラー (Recoverable Error): ファイルが見つからない、ネットワーク接続が切れた、不正な入力があったなど、プログラムが予期し、適切に対処すべきエラー。

Rustは、この2種類のエラーを異なる方法で扱います。回復不能なエラーには `panic!` を、回復可能なエラーには `Result<T, E>` 型を使います。

## 22.2 `Result<T, E>` 型によるエラー処理

`Result<T, E>` は、成功した場合は `Ok(T)` を、失敗した場合は `Err(E)` を返す `enum` です。
- `Ok(T)`: 成功した場合の値。
- `Err(E)`: 失敗した場合のエラー。

`match` 式を使えば、`Result` の `Ok` と `Err` の両方のケースに網羅的に対応することを、コンパイラが強制してくれます。これにより、エラーの見落としを防ぐことができます。

### `unwrap` と `expect`：エラー時のパニック

- `f.unwrap()`: `Result` が `Ok` なら中の値を返し、`Err` ならパニックする。
- `f.expect("Failed to open file")`: `unwrap` と似ているが、パニック時のエラーメッセージをカスタマイズできる。

これらのメソッドは、プロトタイピングや「この処理は絶対に失敗しない」と確信できる場面では便利ですが、本番コードでの多用は避けるべきです。

## 22.3 `?` 演算子によるエラーの伝播

エラーが発生した場合、それを呼び出し元の関数に伝えて処理を委ねたい（エラーの伝播）ことがよくあります。`?` 演算子は、この定型的な処理を非常に簡潔に書くための糖衣構文です。

```rust
fn read_file(path: &str) -> Result<String, std::io::Error> {
    let contents = std::fs::read_to_string(path)?;
    Ok(contents)
}
```

`?` 演算子は、`Result` を返す関数の内部でしか使えません。`main` 関数も `Result` を返すように変更することで、`?` を使った簡潔なエラー処理が可能になります。

### `main` 関数で `Result` を返す

`main` 関数の戻り値を `Result<(), Box<dyn Error>>` にすると、`main` 関数内で `?` 演算子が使えるようになります。

```rust
fn main() -> Result<(), Box<dyn Error>> {
    let contents = read_file("example.txt")?;
    println!("File contents: {}", contents);
    Ok(())
}
```

`Box<dyn Error>` は「`Error` トレイトを実装した任意のエラー型」を意味するトレイトオブジェクトで、様々な種類のエラーを統一的に扱うのに便利です。

## 22.4 `?` 演算子を使える条件

`?` 演算子は、`From` トレイトを実装したエラー型の間で自動的な型変換を行います。これにより、異なる種類のエラーを一つの関数でまとめて扱うことが容易になります。

```rust
fn read_file(path: &str) -> Result<String, std::io::Error> {
    let contents = std::fs::read_to_string(path)?;
    Ok(contents)
}
```

## 22.5 まとめ

- Rust はエラーを、回復不能な `panic!` と、回復可能な `Result<T, E>` に分類する。
- `Result<T, E>` は、成功 (`Ok`) と失敗 (`Err`) の両方の可能性を型レベルで表現し、`match` 式で網羅的なエラー処理を強制する。
- `unwrap` や `expect` は `Result` を簡潔に扱えるが、`Err` の場合にパニックするため、使用は慎重に行うべき。
- `?` 演算子は、`Result` が `Err` なら早期リターンし、`Ok` なら中の値を返す、エラー伝播のための便利な糖衣構文。
- `main` 関数の戻り値を `Result<(), Box<dyn Error>>` にすることで、アプリケーション全体で `?` 演算子を使った統一的なエラーハンドリングが可能になる。

---

エラーを適切に処理する能力は、信頼性の高いソフトウェアを作る上で不可欠です。次の章では、複数の処理を同時に実行するための「並行処理」について学び、Rustがいかにしてデータ競合のような並行処理特有のバグを防いでいるのかを探ります。
