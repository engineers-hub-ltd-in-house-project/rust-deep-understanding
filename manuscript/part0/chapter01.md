# 第 1 章：なぜ Python/Go エンジニアが Rust を学ぶのか

## この章のゴール
- Python/Go エンジニアが Rust を学ぶべき理由を理解する。
- Rust がどのような問題を解決するために生まれたのかを知る。
- 本書を通じてどのようなスキルが身につくかの全体像を掴む。

---

## 1.1 Python と Go、それぞれの強みと「次の一歩」

あなたはこれまで、Python や Go といった優れた言語を使いこなし、多くのアプリケーションを開発してきたことでしょう。

- Python はその柔軟性と豊富なライブラリから、データサイエンス、機械学習、Web アプリケーション開発など、多岐にわたる分野で圧倒的な生産性を誇ります。
- Go はシンプルさと効率的な並行処理モデルにより、マイクロサービスや CLI ツールなど、信頼性の高いバックエンドシステムを迅速に構築することを得意としています。

これらの言語は素晴らしいツールですが、実務経験を積む中で、時として次のような「あと一歩」を感じる場面に遭遇したことはありませんか？

- 実行時エラーの不安 (Python): `TypeError: 'NoneType' object is not iterable` や `KeyError` といったエラーが、テストをすり抜けて本番環境で発生してしまう。型ヒントは便利ですが、コンパイル時にこれらのエラーを完全に防ぐことはできません。
- 依存関係の迷路 (Python): プロジェクトごとに `venv` を作り、`requirements.txt` を管理するものの、チームメンバーやデプロイ環境で微妙なバージョンの違いによる問題が起きることがある。「私の環境では動いたのに…」という経験はありませんか？
- nil ポインタの恐怖 (Go): シンプルで強力な Go ですが、`nil` が予期せぬ箇所で現れると `panic: runtime error: invalid memory address or nil pointer dereference` でプログラムがクラッシュします。
- エラーハンドリングの定型句 (Go): `if err != nil { return err }` は明示的で良いパターンですが、コードが冗長になりがちで、本当に重要なビジネスロジックが埋もれてしまうことがあります。

こうした課題意識こそが、あなたが次のステップへ進むためのサインです。そして、その有力な選択肢となるのが Rust なのです。

## 1.2 Rust が解決する問題

Rust は、これまでのプログラミング言語が抱えていた根本的なトレードオフ、すなわち 「実行速度」と「安全性」の二者択一 を解決するために生まれました。

C/C++ のような低レベル言語は最高のパフォーマンスを提供しますが、メモリ管理を手動で行う必要があり、セグメンテーション違反やデータ競合といった深刻なバグを生み出しやすいという問題を抱えています。

一方、Python や Go のような高レベル言語は、ガベージコレクションによってメモリ管理を自動化し安全性を高めましたが、その代償としてパフォーマンスのオーバーヘッドや予測不能な一時停止を受け入れなければなりませんでした。

Rust は、このどちらの陣営にも属しません。「ゼロコスト抽象化」 と 「所有権システム」 という革新的な仕組みによって、C/C++ に匹敵するパフォーマンスと、高レベル言語のような安全性を両立 させることに成功したのです。

| 特徴 | Python / Go | Rust |
|:---|:---:|:---:|
| メモリ管理 | ガベージコレクション (GC) | 所有権システム (コンパイル時) |
| パフォーマンス | GC によるオーバーヘッドあり | C/C++ に匹敵 (ゼロコスト抽象化) |
| 並行処理 | GIL(Python), Goroutine(Go) | データ競合をコンパイル時に防止 |
| エラー処理 | 例外, `if err != nil` | `Result`/`Option` 型で網羅的チェック |
| 安全性 | メモリ安全 | メモリ安全、スレッド安全 |

## 1.3 なぜ「今」、Rust を学ぶのか？

Rust はもはや実験的な言語ではありません。世界中のトップ企業が、その信頼性とパフォーマンスを評価し、ミッションクリティカルなシステムに採用しています。

- Linux Kernel: 一部のドライバが Rust で記述され始めています。
- Amazon Web Services (AWS): Firecracker など、パフォーマンスが重要な基盤部分で広く採用。
- Cloudflare: ネットワークサービスの中核で利用。
- Microsoft: Windows の一部コンポーネントを Rust で書き換えるプロジェクトが進行中。

Python/Go エンジニアであるあなたが Rust を学ぶことで、以下のようなキャリアの可能性が広がります。

1.  パフォーマンスクリティカルな部分の置き換え: Python や Go のアプリケーションでボトルネックとなっている部分を Rust で書き直し、FFI (Foreign Function Interface) で連携させることで、システム全体のパフォーマンスを劇的に向上させることができます。
2.  新しい領域への挑戦: OS、組み込み、ゲームエンジン、ブロックチェーンなど、これまで C/C++ が主流だったシステムプログラミングの領域に、メモリ安全性を確保しながら挑戦できます。
3.  市場価値の向上: Rust を扱えるエンジニアはまだ希少であり、高い需要があります。既存のスキルセットに Rust を加えることで、あなたの市場価値は大きく向上するでしょう。

## 1.4 本書の学習スタイル：体験を通した理解

多くの入門書は、知識を「読む」ことに重点を置いています。しかし本書は、あなたが知識を「体験する」ことを最優先に設計されています。私たちは、プログラミングの学習において最も重要なのは、実際にコードを書き、動かし、時には意図的に壊して、そこから得られるフィードバック（特にコンパイラのエラーメッセージ）から学ぶことだと信じています。

この「体験的学習サイクル」をサポートするため、本書は以下の原則に基づいています。

1.  **CLI 中心のアプローチ**: 学習の基本は、あなたのローカルマシンで
    ```sh
    cargo new
    ```
    でプロジェクトを作り、
    ```sh
    cargo run
    ```
    で実行するサイクルです。これにより、実際の開発フローに最初から慣れ親しむことができます。
2.  **対話的な試行錯誤**: 第 2 章では `evcxr` という CLI REPL (対話型実行環境) をセットアップします。これにより、書籍の短いコード片をすぐに試したり、自分なりの実験をしたりすることが容易になります。
3.  **エラーは最高の教師**: 本書では「このコードをこう変えたらどうなるでしょう？」といった問いかけを頻繁に行います。私たちは、あなたが積極的にコンパイルエラーを体験することを推奨します。Rust のコンパイラは非常に親切で、そのエラーメッセージは最高の学習教材です。エラーと対話し、解決するプロセスこそが、あなたを本当の意味で「Rust が書ける」エンジニアへと成長させます。

本書は、ただ読み進めるのではなく、常にあなたの隣にターミナルを開き、コードを打ち込み、実験し、そして時には頭を悩ませながら進むことを前提としています。「わかった気になる」のではなく、「やってみて、わかった」という実感を積み重ねていきましょう。

## 1.5 本書の学習ロードマップ

本書は、あなたが Rust で挫折することなく、着実にスキルを習得できるよう、以下の構成で設計されています。

- **第0部：導入編**
  なぜ Rust を学ぶのか、その動機と全体像を掴みます。

- **第1部〜第4部：基礎から応用へ**
  所有権、データ構造、トレイト、プロジェクト管理といった Rust の中核となる概念を、ステップバイステップで確実に習得します。「なぜこうなっているのか？」を常に問いかけ、「確実な理解」を積み重ねていきます。

- **第5部〜第7部：実践と発展**
  Rust の真価が発揮される並行処理や非同期プログラミングを学び、CLI ツールや Web アプリケーションといった実践的なプロジェクトを構築します。最後に、マクロや `unsafe` といった、より発展的なトピックに触れます。

---

この章を読み終えたあなたは、Rust という言語がなぜこれほどまでに注目を集めているのか、そしてそれを学ぶことがあなたのキャリアにとってどれほど大きな意味を持つのかを理解できたはずです。

次の章では、早速 Rust の開発環境をセットアップし、記念すべき最初のコードを書いていきましょう。
