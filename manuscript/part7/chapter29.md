# 第 29 章：マクロ：コードを書くコード

## この章のゴール
- `println!` や `vec!` が関数ではなく宣言的マクロであることを説明できる。
- `macro_rules!` を使って、独自の簡単な宣言的マクロを定義できる。
- 手続きマクロ（`derive`, 属性風, 関数風）の3つの種類と、それぞれの典型的なユースケースを説明できる。

---

## 29.1 なぜマクロが必要か？：メタプログラミング

マクロは、Rustのメタプログラミング機能の一つです。メタプログラミングとは、「コードを書くコード」を書く技術のことです。
1.  可変長引数: `println!` のように、任意の数の引数を取る関数を定義する。
2.  コードの抽象化とDRY原則: `#[derive(Debug)]` のように、定型的なコード（ボイラープレート）の記述を自動化する。
3.  ドメイン固有言語 (DSL) の構築: `axum` のルーティング定義のように、特定の目的に特化したミニ言語をRustの構文内に埋め込む。

## 29.2 宣言的マクロ vs 手続きマクロ

Rustのマクロは、大きく2つのカテゴリに分けられます。
- 宣言的マクロ (Declarative Macros): `macro_rules!` を使って定義する。「マッチング」と「置換」のシステムで動作し、`match` 式に似た構文を持つ。
- 手続きマクロ (Procedural Macros): より強力で、コンパイル時にRustコードを引数として受け取り、新しいRustコードを生成する関数。`derive` マクロなどがこれにあたる。

## 29.3 `macro_rules!` による宣言的マクロ

`println!` や `vec!` は宣言的マクロです。`vec!` マクロを独自に実装してみることで、その仕組みを理解しましょう。
```
でプロジェクトを作り、簡単なマクロを定義してみましょう。

このマクロは、`$($element:expr),*` というパターンで、カンマ区切りの任意の数の式 (`expr`) にマッチします。そして、マッチした式を使って `Vec` を作成するコードに展開されます。

## 29.4 手続きマクロ

手続きマクロは、コンパイル時にコードを生成する特殊なクレートとして実装されます。3つの種類があります。
1.  カスタム `derive` マクロ: `#[derive(MyTrait)]` のように、`struct` や `enum` に `impl` ブロックを自動生成する。`serde` の `#[derive(Serialize)]` が代表例。
2.  属性風マクロ (Attribute-like macros): `#[my_attribute]` のように、任意のアイテム（関数など）に付与して、そのアイテムを変更する。`axum` の `#[axum::async_trait]` や `tokio` の `#[tokio::main]` がこれにあたる。
3.  関数風マクロ (Function-like macros): `my_macro!(...)` のように、関数のように呼び出せるが、引数のトークンストリームを直接操作できる。

手続きマクロの作成は高度なトピックですが、既存のマクロが裏側で何をしているかを理解することは、エコシステムのライブラリを使いこなす上で重要です。

## 29.5 まとめ

- マクロは、コンパイル時にコードを生成するRustのメタプログラミング機能。
- 可変長引数、定型コードの削減、DSLの構築といった、通常の関数では実現できないことを可能にする。
- 宣言的マクロ は `macro_rules!` を使い、パターンマッチングでコードを置換・生成する。`vec!` が代表例。
- 手続きマクロ は、コードを直接操作する強力なマクロで、カスタム `derive`、属性風、関数風の3種類がある。`#[derive(Debug)]` や `#[tokio::main]` が代表例。

---

マクロは、Rustの表現力を飛躍的に高める強力なツールです。次の章では、Rustの安全神話の裏側にある `unsafe` キーワードと、FFI（Foreign Function Interface）について探求し、Rustがどのように低レベルな世界と対話しているのかを学びます。
