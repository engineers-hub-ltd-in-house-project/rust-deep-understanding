# 第 29 章：マクロの基礎

## この章のゴール
- 宣言的マクロ (`macro_rules!`) と手続き的マクロ（カスタム `derive` など）の違いを理解する。
- 簡単な宣言的マクロを定義し、コードの繰り返しを減らすために利用できるようになる。
- `println!`, `vec!`, `assert_eq!` など、これまで使ってきたマクロがどのように機能しているかの概要を理解する。
- マクロがコンパイル時にコードを生成するメタプログラミングの一形態であることを理解する。

## 前章の復習
前の章では、既存の Python/Go プロジェクトに Rust を統合したり、Rust へ移行したりするための戦略について学びました。FFI やストラングラー・パターンといったアプローチを見ました。

## なぜこれが必要なのか？
これまでに `println!` や `vec!` など、関数呼び出しに似ているけれど末尾に `!` がつく構文を数多く使ってきました。これらは**マクロ**と呼ばれます。マクロは、Rust のコードを引数として受け取り、コンパイル時に別の Rust コードを生成する仕組みです。いわば「コードを書くコード」であり、Rust のメタプログラミング機能の中核をなします。

マクロを使うことで、以下のようなことが可能になります。
- **DRY (Don't Repeat Yourself) の徹底:** 関数では表現できないような、コードの構造的な繰り返しを減らす。
- **DSL (Domain Specific Language) の構築:** 特定の問題領域に特化した、より表現力豊かな構文を Rust 内に作り出す。
- **コンパイル時チェックの強化:** コンパイル時に特定の条件を検証するコードを生成する。

## 宣言的マクロ (`macro_rules!`)
宣言的マクロは、`match` 式に似た構文で定義します。パターンにマッチしたコードを受け取り、それを別のコードに変換します。

### `vec!` マクロの簡単な実装
`vec!` マクロがどのように実装されているか、簡略版を見てみましょう。
```rust
#[macro_export]
macro_rules! my_vec {
    ( $( $x:expr ),* ) => {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}

fn main() {
    let v = my_vec![1, 2, 3];
    // これは以下のように展開される:
    // {
    //     let mut temp_vec = Vec::new();
    //     temp_vec.push(1);
    //     temp_vec.push(2);
    //     temp_vec.push(3);
    //     temp_vec
    // }
}
```
- `$x:expr`: `x` という名前で式 (`expr`) をキャプチャする。
- `$( ... ),*`: `...` の中のパターンが `,` で区切られて0回以上繰り返されることを示す。

## 手続き的マクロ (Procedural Macros)
手続き的マクロは、コンパイラの API を使って Rust のコードを直接操作する、より強力なマクロです。これらはそれ自体が独立したクレートとして実装されます。
手続き的マクロには3つの種類があります。
1.  **カスタム `derive` マクロ:** `#[derive(MyTrait)]` のように、構造体や列挙型にアノテーションを付けると、指定されたトレイトの実装コードを自動生成します。`serde` の `#[derive(Serialize)]` がこれにあたります。
2.  **属性風マクロ:** `#[my_attribute]` のように、任意のアイテムに付与できるカスタム属性を定義します。`actix-web` や `axum` の `#[get("/path")]` などが例です。
3.  **関数風マクロ:** `my_macro!()` のように、宣言的マクロと似た形で呼び出せますが、より複雑なコード解析と生成が可能です。

手続き的マクロの作成は高度なトピックですが、`serde` や `clap` の `derive` マクロのように、私たちは既にその恩恵を大いに受けています。

## マクロの衛生 (Hygiene)
Rust の宣言的マクロは、ほとんどの場合「衛生的」です。これは、マクロ内で導入された変数が、マクロが呼び出されたスコープ内の変数と偶然に名前が衝突しないように、コンパイラが内部で自動的に名前を変更してくれることを意味します。これにより、予期せぬバグを防ぐことができます。

## よくあるエラーと対処法
### エラー 1: マクロのデバッグが難しい
**原因:** マクロはコンパイル時に展開されるため、エラーメッセージが展開後のコードを指してしまい、元のマクロのどこに問題があるのか分かりにくいことがあります。
**解決法:**
- `cargo expand` というツールを使うと、マクロがどのように展開されたかを確認できます。
- マクロの定義を少しずつ変更し、どの変更がエラーを引き起こしたかを特定します。

## この章のまとめ
- マクロは、コンパイル時に Rust のコードを生成するメタプログラミング機能。
- 宣言的マクロ (`macro_rules!`) は、パターンマッチングに基づいてコードを変換する。
- 手続き的マクロ（カスタム `derive` など）は、より強力で、コンパイラの AST を直接操作する。
- 私たちは `vec!`, `println!`, `#[derive]` などを通じて、日常的にマクロの恩恵を受けている。

## 次の章へ
Rust は、その強力な安全性保証によって多くのバグをコンパイル時に防いでくれます。しかし、時にはその安全装置を意図的に外し、低レベルな操作を行う必要が出てくることもあります。次の章では、Rust の「安全弁」である `unsafe` コードの世界を探求し、どのような場合にそれが必要で、どのように安全に扱うべきかを学びます。

