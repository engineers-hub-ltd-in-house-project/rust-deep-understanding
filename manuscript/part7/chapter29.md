# 第 29 章：マクロの基礎：コードを書くコード

## この章のゴール
- `println!` のようなマクロが、なぜ通常の関数では不可能な「可変長引数」を実現できるのか、その理由を理解する。
- 宣言的マクロ (`macro_rules!`) を使って、コードの繰り返しを減らすための簡単なマクロを自作できるようになる。
- `$(...),*` のような繰り返し構文を使い、`vec!` のような便利なマクロがどのように作られているかを体験的に理解する。
- マクロがコンパイル時にコードを生成する「メタプログラミング」であることを理解する。

---

## 29.1 なぜこれが必要か？ 関数の限界を超える

これまでの章で、私たちは `println!`, `vec!`, `assert_eq!` といった、末尾に `!` が付く構文を当たり前のように使ってきました。これらは**マクロ**と呼ばれます。

ここで一つ疑問が浮かびます。なぜ `println!("Hello, {}!", name)` のように、引数を2つ渡したり、`println!("Hello")` のように1つだけ渡したりできるのでしょうか？通常のRustの関数は、定義された数の引数を正確に受け取らなければなりません。

答えは、**マクロは関数ではない**からです。マクロは、コンパイルプロセス中に実行され、Rustのコードを受け取って、別のRustのコードを生成する、一種の変換プログラムです。つまり「コードを書くコード」であり、これを**メタプログラミング**と呼びます。

この章では、この強力なマクロ機能の基本的な使い方を学びます。

## 29.2 宣言的マクロ `macro_rules!`

Rustには2種類のマクロがありますが、この章ではよりシンプルで一般的な**宣言的マクロ**に焦点を当てます。これは `macro_rules!` というキーワードを使って定義し、`match` 式によく似た構文を持ちます。

### 試してみよう：`vec!` の簡易版 `my_vec!` を作る

`vec![1, 2, 3]` のように、任意の数の要素から `Vec` を作成できるマクロを自作してみましょう。この体験を通して、マクロの仕組みを理解するのが一番の近道です。

`cargo new my-macros` でプロジェクトを作成し、`src/main.rs` を編集します。

```rust
// src/main.rs

// 1. `macro_rules!` でマクロを定義する
macro_rules! my_vec {
    // 2. パターンを定義する
    // `$` でメタ変数を開始
    // `expr` は「式」にマッチすることを示す (フラグメント指定子)
    // `$(...),*` は `...` の内容が `,` で区切られて0回以上繰り返されることを示す
    ( $( $element:expr ),* ) => {
        // 3. 変換後のコードを定義する
        {
            let mut temp_vec = Vec::new();
            // `$(...)*` で繰り返し展開する
            $(
                temp_vec.push($element);
            )*
            temp_vec
        }
    };
}

fn main() {
    let v1 = my_vec![];
    let v2 = my_vec![1, 2, 3];
    let v3 = my_vec!["hello", "world"];

    println!("{:?}", v1); // => []
    println!("{:?}", v2); // => [1, 2, 3]
    println!("{:?}", v3); // => ["hello", "world"]

    // 下記は my_vec![1, 2, 3] がコンパイル時に展開された後のコードのイメージ
    let v_expanded = {
        let mut temp_vec = Vec::new();
        temp_vec.push(1);
        temp_vec.push(2);
        temp_vec.push(3);
        temp_vec
    };
    assert_eq!(v2, v_expanded);
}
```

このコードは、`my_vec![...]` という呼び出しを見つけると、コンパイラが `=>` の後のコードブロックに展開します。`$()` の繰り返し構文によって、引数の数だけ `temp_vec.push(...)` の行が生成されるのがポイントです。

## 29.3 マクロの主な利点

マクロは少し不思議な構文に見えますが、非常に強力です。

1.  **DRY (Don't Repeat Yourself) の徹底**: 関数では共通化できないような、定型的なコード（ボイラープレート）を削減できます。`my_vec!` の例では、`Vec` を初期化して要素を一つずつ `push` する手間をマクロが肩代わりしてくれました。
2.  **DSL (Domain-Specific Language) の構築**: 特定のタスクに特化したミニ言語のようなものを作ることができます。`axum` のルーティング定義や、`clap` の引数定義も、マクロを駆使して実現されています。
3.  **可変長引数の実現**: `println!` や `vec!` のように、引数の数を可変にすることができます。

## 29.4 手続き的マクロについて

もう一つのマクロの種類として、**手続き的マクロ**があります。これらは `#[derive]` や `#[tokio::main]` のような属性として使われることが多く、より複雑なコード生成が可能です。`serde` や `clap` の `derive` マクロは、この手続き的マクロで作られています。手続き的マクロの作成は本書の範囲を超えた高度なトピックですが、私たちは既にその恩恵を大いに受けている、ということだけ覚えておきましょう。

## 29.5 まとめ

- マクロは、コンパイル時にコードを生成するメタプログラミング機能であり、関数ではできないことを実現できる。
- 宣言的マクロ (`macro_rules!`) は、パターンマッチングの仕組みでコードを変換する。
- `$()` 構文を使うことで、可変長の引数を扱ったり、コードを繰り返し展開したりできる。
- マクロは、コードの重複を減らし、より表現力豊かなAPIを構築するための強力なツール。

---

次の章では、Rustの強力な安全性保証を意図的に解除する `unsafe` コードの世界を探求し、どのような場合にそれが必要で、どのように安全に扱うべきかを学びます。

