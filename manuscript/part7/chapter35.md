# 第35章：Unsafe コードと最適化

## この章のゴール
- `unsafe` が、Rustの安全性保証をプログラマの責任で部分的に解除するキーワードであることを理解する。
- `unsafe` が必要になる典型的な状況（FFI、低レベルのデータ構造実装など）を理解する。
- 生ポインタの作成は安全だが、そのデリファレンスには `unsafe` が必要であることをコンパイルエラーを通して体験する。
- `unsafe fn` の呼び出しに `unsafe` ブロックが必要であることを体験する。
- `cargo run --release` を使ったリリースビルドの重要性を理解する。

---

## 31.1 なぜこれが必要か？ コンパイラの限界

Rustの最大の強みは、コンパイラがコードの安全性（特にメモリ安全性）を静的に検証してくれることです。しかし、コンパイラは万能ではありません。コンパイラには安全性を証明できないけれども、プログラマの目から見れば明らかに安全なコードが存在します。

例えば、以下のような状況です。
- FFI: C言語で書かれたライブラリを呼び出す場合、RustコンパイラはCのコードの中身まで検証できません。
- ハードウェアとの対話: 特定のメモリアドレスを直接読み書きする場合など。
- 高度なデータ構造: `Vec` の内部実装のように、パフォーマンスのためにポインタ演算を駆使して借用チェッカのルールを一時的に回避する必要がある場合。

このような状況のために、Rustには「安全性の強制を一時的に解除する扉」として `unsafe` キーワードが用意されています。`unsafe` ブロックを使うことは、プログラマがコンパイラに対して「このコードブロック内の処理については、私がすべての安全性を保証します」と誓約することを意味します。

## 31.2 `unsafe` のスーパーパワー

`unsafe` ブロックの中では、通常のRustコードでは許可されない、以下の5つの操作（スーパーパワー）が解禁されます。

1.  生ポインタのデリファレンス
2.  `unsafe` な関数やメソッドの呼び出し
3.  可変な静的変数へのアクセスや変更
4.  `union` のフィールドへのアクセス
5.  `unsafe` なトレイトの実装

重要な注意: `unsafe` は借用チェッカや所有権システムを無効にするわけではありません。あくまで、上記の特定の操作を許可するだけです。

この章では、最も代表的な1と2を体験します。

### 試してみよう1：生ポインタのデリファレンス

生ポインタ (`*const T`, `*mut T`) は、参照と違い、nullかもしれないし、無効なメモリを指しているかもしれない、危険なポインタです。そのため、その先の値にアクセス（デリファレンス）するには `unsafe` が必要です。

```sh
cargo new unsafe-demo
```

```rust
// src/main.rs
fn main() {
    let mut num = 5;

    // 参照から生ポインタを作成すること自体は安全
    let r1 = &num as *const i32;
    let r2 = &mut num as *mut i32;

    // println!("r1 is: {}", *r1); // 💥 コンパイルエラー！
    // error[E0133]: dereference of raw pointer is unsafe and requires unsafe function or block

    // `unsafe` ブロックで囲むとコンパイルが通る
    unsafe {
        println!("r1 is: {}", *r1);
        println!("r2 is: {}", *r2);
    }
}
```
[Rust Playgroundで試す](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&code=fn%20main%28%29%20%7B%0A%20%20%20%20let%20mut%20num%20%3D%205%3B%0A%0A%20%20%20%20%2F%2F%20%E5%8F%82%E7%85%A7%E3%81%8B%E3%82%89%E7%94%9F%E3%83%9D%E3%82%A4%E3%83%B3%E3%82%BF%E3%82%92%E4%BD%9C%E6%88%90%E3%81%99%E3%82%8B%E3%81%93%E3%81%A8%E8%87%AA%E4%BD%93%E3%81%AF%E5%AE%89%E5%85%A8%0A%20%20%20%20let%20r1%20%3D%20%26num%20as%20%2Aconst%20i32%3B%0A%20%20%20%20let%20r2%20%3D%20%26mut%20num%20as%20%2Amut%20i32%3B%0A%0A%20%20%20%20%2F%2F%20println%21%28%22r1%20is%3A%20%7B%7D%22%2C%20%2Ar1%29%3B%20%2F%2F%20%F0%9F%92%A5%20%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%AB%E3%82%A8%E3%83%A9%E3%83%BC%EF%BC%81%0A%20%20%20%20%2F%2F%20error%5BE0133%5D%3A%20dereference%20of%20raw%20pointer%20is%20unsafe%20and%20requires%20unsafe%20function%20or%20block%0A%0A%20%20%20%20%2F%2F%20%60unsafe%60%20%E3%83%96%E3%83%AD%E3%83%83%E3%82%AF%E3%81%A7%E5%9B%B2%E3%82%80%E3%81%A8%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%AB%E3%81%8C%E9%80%9A%E3%82%8B%0A%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20println%21%28%22r1%20is%3A%20%7B%7D%22%2C%20%2Ar1%29%3B%0A%20%20%20%20%20%20%20%20println%21%28%22r2%20is%3A%20%7B%7D%22%2C%20%2Ar2%29%3B%0A%20%20%20%20%7D%0A%7D)
`*r1` の行をコメントアウトしたり外したりして、コンパイラのエラーを確認してみましょう。`unsafe` ブロックは、このデリファレンスが安全であることをプログラマが保証する境界を示しています。

### 試してみよう2：`unsafe` な関数の呼び出し

`unsafe` とマークされた関数は、呼び出す側がその関数の事前条件をすべて満たしていることを保証しなければなりません。

```rust
// src/main.rs
// Cの `abs` 関数をFFIで呼び出すと仮定
extern "C" {
    fn abs(input: i32) -> i32;
}

fn main() {
    // let result = abs(-3); // 💥 コンパイルエラー！
    // error[E0133]: call to unsafe function is unsafe and requires unsafe function or block

    unsafe {
        // Cの関数を呼び出すのは unsafe
        println!("Absolute value of -3 is: {}", abs(-3));
    }
}
```
[Rust Playgroundで試す](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&code=%2F%2F%20C%E3%81%AE%20%60abs%60%20%E9%96%A2%E6%95%B0%E3%82%92FFI%E3%81%A7%E5%91%BC%E3%81%B3%E5%87%BA%E3%81%99%E3%81%A8%E4%BB%AE%E5%AE%9A%0Aextern%20%22C%22%20%7B%0A%20%20%20%20fn%20abs%28input%3A%20i32%29%20-%3E%20i32%3B%0A%7D%0A%0Afn%20main%28%29%20%7B%0A%20%20%20%20%2F%2F%20let%20result%20%3D%20abs%28-3%29%3B%20%2F%2F%20%F0%9F%92%A5%20%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%AB%E3%82%A8%E3%83%A9%E3%83%BC%EF%BC%81%0A%20%20%20%20%2F%2F%20error%5BE0133%5D%3A%20call%20to%20unsafe%20function%20is%20unsafe%20and%20requires%20unsafe%20function%20or%20block%0A%0A%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20C%E3%81%AE%E9%96%A2%E6%95%B0%E3%82%92%E5%91%BC%E3%81%B3%E5%87%BA%E3%81%99%E3%81%AE%E3%81%AF%20unsafe%0A%20%20%20%20%20%20%20%20println%21%28%22Absolute%20value%20of%20-3%20is%3A%20%7B%7D%22%2C%20abs%28-3%29%29%3B%0A%20%20%20%20%7D%0A%7D)
FFIで外部のライブラリを呼び出す行為は、Rustコンパイラの保証の範囲外であるため、本質的に `unsafe` です。

## 31.3 `unsafe` の安全なカプセル化

`unsafe` を使う際の黄金律は、「`unsafe` ブロックを可能な限り小さくし、その周りに安全なAPIを提供する」ことです。例えば、`Vec` の内部実装には `unsafe` コードが多用されていますが、私たちが `vec.push()` や `vec[i]` を使うときには `unsafe` を書く必要はありません。これは、`Vec` の作者が `unsafe` の詳細を内部にカプセル化し、安全なインターフェースを公開してくれているおかげです。

## 31.4 最適化：まずはリリースビルドから

Rustは「ゼロコスト抽象化」を掲げており、高級な機能を使っても、手で低レベルなコードを書いた場合と同等のパフォーマンスが出ることを目指しています。

`cargo run` は、コンパイル時間が短いデバッグビルドで実行されます。これには最適化がほとんどかかっていません。

```sh
cargo run --release
```

このコマンドで実行されるリリースビルドは、LLVMコンパイラが積極的な最適化（インライン化、ループ展開など）を行います。パフォーマンスを測定する際は、必ず `--release` フラグを付けてください。デバッグビルドと比べて桁違いに速くなることがよくあります。

ほとんどの場合、パフォーマンスの問題はアルゴリズムの改善や、イディオマティックで安全なRustコードを書くことで解決します。`unsafe` を使った手動の最適化は、プロファイリングでボトルネックを特定した後の最終手段と考えるべきです。

## 31.5 まとめ

- `unsafe` は、コンパイラが安全性を検証できない処理を、プログラマの責任において許可するためのキーワード。
- 生ポインタのデリファレンスやFFI呼び出しなどが `unsafe` ブロック内で可能になる。
- `unsafe` を使う際は、その範囲を最小限に留め、安全なインターフェースでラップすることが極めて重要。
- パフォーマンスを評価・改善したい場合、最初のステップは常に `cargo run --release` でリリースビルドを実行すること。

---

次の章では、開発したアプリケーションをどのようにして本番環境にデプロイし、運用していくかについての実践的な知識を学びます。
