# 第33章：Python/Go コードからの移行戦略

## この章のゴール
- Rust を既存の Python/Go プロジェクトに組み込む FFI (Foreign Function Interface) の基本戦略を理解する。
- `PyO3` を使い、Python の CPU バウンドな処理を Rust で高速化する具体的な方法を体験する。
- Go から Rust の関数を C ABI 経由で呼び出す方法の概要を理解する。
- マイクロサービスアーキテクチャにおいて、サービス単位で Rust に置き換える「ストラングラー・フィグ・パターン」を理解する。

---

## 33.1 なぜこれが必要か？ 現実世界のソフトウェア開発
多くの場合、私たちの仕事はゼロから新しいものを作る「グリーンフィールド」開発だけではありません。Python や Go で書かれ、長年ビジネスを支えてきた巨大な「レガシー」コードベースを扱うことも少なくありません。

この章の目的は、「すべてを Rust で書き直す」ことではなく、既存の Python/Go 資産を尊重しつつ、Rust の強みをどのように戦略的に統合し、システム全体をより良くしていくか、という現実的なアプローチを学ぶことです。

## 33.2 戦略1：FFI による機能拡張（ピンポイント高速化）
最も一般的で、リスクが低く、効果を実感しやすいのがこのアプローチです。アプリケーション全体の中で、パフォーマンスが特に問題となる、CPU バウンドな（計算量が非常に多い）関数を特定し、その関数だけを Rust で書き直し、元の言語から呼び出す方法です。これを FFI (Foreign Function Interface) と呼びます。

### 試してみよう：Python の処理を `PyO3` で高速化する
Python は素晴らしい言語ですが、計算処理が遅いという弱点があります。`PyO3` は、この問題を解決するための強力なツールです。

1.  **プロジェクトの準備**: `maturin` というツールを使い、`PyO3` を使った Rust ライブラリを簡単に開発できます。
    ```bash
    # Python 仮想環境を作り、maturin をインストール
    python -m venv .venv && source .venv/bin/activate
    pip install maturin
    # プロジェクト雛形を作成
    maturin new -b pyo3 py-rust-ext
    ```

2.  **Rust でロジックを実装**: `py-rust-ext/src/lib.rs` に計算量の多い処理を実装します。`#[pyfunction]` 属性を付けるだけで、Python から呼び出せるようになります。
    ```rust
    // py-rust-ext/src/lib.rs
    use pyo3::prelude::*;

    #[pyfunction]
    fn sum_as_string(a: usize, b: usize) -> PyResult<String> {
        Ok((a + b).to_string())
    }

    #[pymodule]
    fn py_rust_ext(_py: Python, m: &PyModule) -> PyResult<()> {
        m.add_function(wrap_pyfunction!(sum_as_string, m)?)?;
        Ok(())
    }
    ```

3.  **ビルドと呼び出し**: `maturin develop` でビルドすると、Python から `import py_rust_ext` として呼び出せます。データ分析、画像処理、機械学習の前処理など、計算ボトルネックがある場所で絶大な効果を発揮します。

### Go との連携
Go と Rust を連携させるには、C 言語の ABI (Application Binary Interface) を介するのが一般的です。Rust 側で C 互換の関数 (`extern "C" fn`) を持つ共有ライブラリを作成し、Go 側で `cgo` を使ってその関数を呼び出します。

## 33.3 戦略2：サービス単位での置き換え
もう一つの強力な戦略は、マイクロサービスアーキテクチャにおけるサービス単位での置き換えです。

特定のサービス（例：アクセスが集中する認証サービス、大量のデータを処理する ETL サービスなど）のパフォーマンスや信頼性が問題になっている場合、そのサービスだけを Rust で再実装し、同じ API 仕様 (REST, gRPC など) を公開します。そして、ロードバランサーの設定を切り替えて、リクエストを古いサービスから新しい Rust のサービスに向けるのです。

このアプローチは「ストラングラー・フィグ・パターン」とも呼ばれ、既存のシステム全体を止めることなく、一部分ずつ安全にリプレースしていくことができます。

## 33.4 まとめ
- 既存の Python/Go コードベースに Rust を導入する場合、すべてを書き換える必要はありません。
- FFI は、CPU バウンドな処理を Rust で高速化するための強力な武器であり、`PyO3` を使えば Python とシームレスに連携できます。
- マイクロサービスアーキテクチャでは、問題となっているサービスを丸ごと Rust で再実装し、ネットワーク経由で連携させるのが有効な戦略です。
- 成功の鍵は、プロファイリングによるボトルネックの正確な特定と、小さく始めて徐々に範囲を広げていくアプローチです。

---
次の章では、Rust のメタプログラミング機能の核である「マクロ」の基礎について学びます。
