# 第 30 章：Unsafe コードと最適化

## この章のゴール
- `unsafe` キーワードが Rust のどの安全保証を無効にするかを理解する。
- `unsafe` が必要になる典型的な状況（FFI、低レベルなハードウェア操作など）を理解する。
- 生ポインタ (`*const T`, `*mut T`) の基本的な使い方と、それが安全な参照とどう違うかを理解する。
- `unsafe` ブロックを可能な限り小さく保ち、安全な抽象化でラップすることの重要性を理解する。
- Rust のゼロコスト抽象化の概念と、基本的な最適化の考え方（例: `#[inline]`, `--release` ビルド）を理解する。

## 前章の復習
前の章では、マクロの基礎について学びました。宣言的マクロと手続き的マクロの違い、そしてそれらがどのようにしてコードの繰り返しを減らし、表現力を高めるかを見ました。

## なぜこれが必要なのか？
Rust の最大の強みは、コンパイラによる静的な安全性保証（メモリ安全性、スレッド安全性）です。しかし、この保証は、コンパイラがすべての情報を把握できる範囲でしか機能しません。世の中には、コンパイラが安全性を検証できない、しかしプログラマが「これは安全である」と知っている状況が存在します。
- **C ライブラリの呼び出し (FFI):** コンパイラは C のコードが何をするかを知りません。
- **ハードウェアとの直接対話:** 特定のメモリアドレスにあるレジスタを読み書きするなど。
- **コンパイラに証明できない複雑なデータ構造の実装:** 一部の高度なデータ構造では、借用チェッカのルールを一時的に回避する必要があります。

このような場合に、プログラマがコンパイラに対して「ここから先は私の責任で安全を保証する」と宣言するためのキーワードが `unsafe` です。

## `unsafe` のスーパーパワー
`unsafe` ブロックの中では、通常の Rust コードでは許されていない、以下の5つの操作（スーパーパワー）が解禁されます。
1.  **生ポインタのデリファレンス:** `*const T` や `*mut T` を使って、メモリ上の任意のアドレスを読み書きする。
2.  **`unsafe` な関数やメソッドの呼び出し:** `unsafe fn` として定義された関数（FFI の関数など）を呼び出す。
3.  **可変な静的変数へのアクセスや変更:** `static mut` で定義されたグローバル変数を操作する。
4.  **`union` のフィールドへのアクセス:** C 言語スタイルの共用体にアクセスする。
5.  **`unsafe` なトレイトの実装:** `unsafe trait` を実装する。

`unsafe` は借用チェッカを無効にする**わけではない**ことに注意してください。あくまで、上記の5つの操作を許可するだけです。

## 生ポインタ
- `*const T` (不変), `*mut T` (可変)
- 参照 (`&T`, `&mut T`) と異なり、以下の保証が**ありません**。
    - 非 null である保証がない。
    - 有効なメモリ位置を指している保証がない。
    - エイリアシング（複数のポインタが同じ場所を指す）に関するルールがない。
- 生ポインタを作成すること自体は安全ですが、それをデリファレンス（`*` 演算子で値にアクセス）するのは `unsafe` ブロック内でのみ許可されます。

```rust
let mut num = 5;

// 生ポインタの作成は安全
let r1 = &num as *const i32;
let r2 = &mut num as *mut i32;

unsafe {
    // デリファレンスは unsafe
    println!("r1 is: {}", *r1);
    *r2 = 10;
    println!("num is now: {}", num);
}
```

## `unsafe` の安全なカプセル化
`unsafe` を使う際の黄金律は、「`unsafe` ブロックを可能な限り小さくし、その周りに安全な API を提供する」ことです。`std::vec::Vec` の `split_at_mut` メソッドが良い例です。
```rust
fn split_at_mut(&mut self, mid: usize) -> (&mut [T], &mut [T]) {
    // 安全な Rust では、同じスライスから2つの可変参照を同時に作ることはできない
    // しかし、これらが重複しないスライスを指すことは明らか
    // そこで unsafe を使って実装する
    let len = self.len();
    let ptr = self.as_mut_ptr();
    assert!(mid <= len);

    unsafe {
        (
            from_raw_parts_mut(ptr, mid),
            from_raw_parts_mut(ptr.add(mid), len - mid),
        )
    }
}
```
この関数の**シグネチャ**には `unsafe` が付いていません。これは、`split_at_mut` の**利用者**は、この関数を安全に呼び出せることを意味します。`unsafe` の複雑さは関数の内部に完全にカプセル化されています。

## 最適化とゼロコスト抽象化
Rust は「ゼロコスト抽象化」という原則を掲げています。これは、イテレータや `async/await` のような高級な機能を使っても、手で低レベルなコードを書いた場合と同等のパフォーマンスが得られるべきだ、という意味です。

- **リリースビルド:** `cargo run --release` や `cargo build --release` でコンパイルすると、LLVM バックエンドが積極的な最適化（インライン化、ループ展開など）を行います。開発ビルド (`cargo run`) とはパフォーマンスが桁違いに変わることがあります。
- **インライン化:** `#[inline]` 属性を関数につけると、コンパイラに対してその関数を呼び出し元に展開する（インライン化する）よう促すことができます。これにより関数呼び出しのオーバーヘッドがなくなりますが、コードサイズが大きくなる可能性もあります。

ほとんどの場合、プロファイラでボトルネックを特定するまでは、手動での最適化は不要です。まずは `--release` ビルドで性能を測定することから始めましょう。

## この章のまとめ
- `unsafe` は、コンパイラが安全性を検証できない処理を、プログラマの責任において許可するためのキーワード。
- 生ポインタのデリファレンスや FFI 呼び出しなどが `unsafe` ブロック内で可能になる。
- `unsafe` を使う際は、その範囲を最小限に留め、安全なインターフェースでラップすることが極めて重要。
- Rust のゼロコスト抽象化により、高級な機能もパフォーマンスの犠牲なく利用できる。最適化の第一歩は `--release` ビルド。

## 次の章へ
Rust の深淵を覗き、その安全性メカニズムの境界を探求しました。これで、理論から実践、そして低レベルな操作まで、Rust の主要な側面はほぼカバーしました。最後の章では、開発したアプリケーションをどのようにして本番環境にデプロイし、運用していくかについての実践的な知識を学びます。
