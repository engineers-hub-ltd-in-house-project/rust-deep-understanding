# 第 30 章：`unsafe` Rust と FFI

## この章のゴール
- `unsafe` がRustの安全チェックを無効にするのではなく、コンパイラが保証できない不変条件の維持をプログラマに委ねるためのキーワードであることを説明できる。
- `extern "C"` を使い、C言語の関数をRustから呼び出したり、Rustの関数をC言語から呼び出せるようにエクスポートしたりできる。
- `#[no_mangle]` 属性が、コンパイル後の関数名を維持し、FFIでリンクするために必要な理由を説明できる。

---

## 30.1 `unsafe` の力と責任

Rustは、その強力な静的解析によって、メモリ安全性やスレッド安全性をコンパイル時に保証します。しかし、コンピュータができることすべてをコンパイラが理解し、検証できるわけではありません。ハードウェアの直接操作や、C言語のような他の言語との連携など、コンパイラが安全性を保証できない領域が存在します。

`unsafe` ブロックや `unsafe fn` の中でプログラマができるようになる、5つの「スーパーパワー」があります。

1.  生ポインタ (`*const T`, `*mut T`) の参照外し
2.  `unsafe` な関数やメソッドの呼び出し
3.  `static mut` 変数へのアクセスや変更
4.  `unsafe` なトレイトの実装
5.  `union` のフィールドへのアクセス

これらの操作は、コンパイラの安全チェックを迂回するため、使用には細心の注意が必要です。`unsafe` を使う際は、そのブロックがなぜ安全であるかをドキュメント化し、カプセル化して安全なAPIを外部に提供するのが良いプラクティスです。

## 30.2 生ポインタの参照外し

`unsafe` の最も一般的な用途は、**生ポインタ (raw pointers)** の操作です。

- `*const T` (不変), `*mut T` (可変)
- 借用規則のチェックがない。
- `null` である可能性が保証されない。
- 自動的なクリーンアップ（`Drop`）がない。

参照 (`&T`) を生ポインタにキャストするのは安全ですが、生ポインタを逆参照して中の値にアクセスする (`*raw_ptr`) のは `unsafe` です。

## 30.3 FFI：他の言語との対話

`unsafe` が不可欠となるもう一つの重要な領域が、**FFI (Foreign Function Interface)** です。これにより、RustのコードからC言語で書かれたライブラリの関数を呼び出したり、逆にRustで書いた関数をCのコードから利用したりできます。

- **`extern "C"`**: 関数のABI (Application Binary Interface) をC言語の規約に合わせることをコンパイラに指示します。
- **`#[no_mangle]`**: コンパイラに関数名をマングリング（変更）しないように指示します。これにより、Cのリンカが `my_rust_function` という名前で関数を見つけられるようになります。

### 試してみよう：Cの `abs` 関数をRustから呼び出す

```sh
// cargo new unsafe-demo
```
でプロジェクトを作り、試してみましょう。

```rust
// src/main.rs

// 1. `macro_rules!` でマクロを定義する
macro_rules! my_vec {
    // 2. パターンを定義する
    // `$` でメタ変数を開始
    // `expr` は「式」にマッチすることを示す (フラグメント指定子)
    // `$(...),*` は `...` の内容が `,` で区切られて0回以上繰り返されることを示す
    ( $( $element:expr ),* ) => {
        // 3. 変換後のコードを定義する
        {
            let mut temp_vec = Vec::new();
            // `$(...)*` で繰り返し展開する
            $(
                temp_vec.push($element);
            )*
            temp_vec
        }
    };
}

fn main() {
    let v1 = my_vec![];
    let v2 = my_vec![1, 2, 3];
    let v3 = my_vec!["hello", "world"];

    println!("{:?}", v1); // => []
    println!("{:?}", v2); // => [1, 2, 3]
    println!("{:?}", v3); // => ["hello", "world"]

    // 下記は my_vec![1, 2, 3] がコンパイル時に展開された後のコードのイメージ
    let v_expanded = {
        let mut temp_vec = Vec::new();
        temp_vec.push(1);
        temp_vec.push(2);
        temp_vec.push(3);
        temp_vec
    };
    assert_eq!(v2, v_expanded);
}
```
[Rust Playgroundで試す](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&code=extern%20%22C%22%20%7B%0A%20%20%20%20//%20C%E3%81%AE%E6%A8%99%E6%BA%96%E3%83%A9%E3%82%A4%E3%83%96%E3%83%A9%E3%83%AA%20libc%20%E3%81%AB%E3%81%82%E3%82%8B%20abs%20%E9%96%A2%E6%95%B0%E3%82%92%E5%AE%A3%E8%A8%80%0A%20%20%20%20fn%20abs(input%3A%20i32)%20-%3E%20i32%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20//%20C%E8%A8%80%E8%AA%9E%E3%81%AE%E9%96%A2%E6%95%B0%E5%91%BC%E3%81%B3%E5%87%BA%E3%81%97%E3%81%AF%20unsafe%20%E3%83%96%E3%83%AD%E3%83%83%E3%82%AF%E5%86%85%E3%81%A7%E8%A1%8C%E3%81%86%0A%20%20%20%20%20%20%20%20println!(%22Absolute%20value%20of%20-3%20according%20to%20C%3A%20%7B%7D%22%2C%20abs(-3))%3B%0A%20%20%20%20%7D%0A%7D)

## 30.4 まとめ

- `unsafe` キーワードは、コンパイラが安全性を保証できない5つの操作を許可するためのもの。`unsafe` コードの安全性を保証するのはプログラマの責任。
- 生ポインタ (`*const T`, `*mut T`) は、借用規則やnullチェックから解放されたポインタであり、その参照外しは `unsafe` ブロック内で行う必要がある。
- FFI (Foreign Function Interface) は、Rustと他の言語（主にC）のコードを連携させるための仕組みで、`unsafe` を必要とする。
- `extern "C"` はC言語のABIを使うことを示し、`#[no_mangle]` は関数名のマングリングを抑制する。

---

`unsafe` は諸刃の剣です。大きな力を与えてくれますが、使い方を誤ればRustの安全保証をすべて台無しにしてしまいます。しかし、FFIや低レベルな最適化のために、その存在は不可欠です。

次の最終章では、これまでの学習を振り返り、Rustのエコシステムをさらに探求するための次のステップについて議論します。

