# 第 5 章：関数とクロージャ

## この章のゴール
- `fn` キーワードを使って関数を定義し、引数と戻り値の型を正しく指定できる。
- 文 (Statement) と式 (Expression) の違いを明確に説明できる。
- `return` キーワードの明示的な使用と、式としての暗黙的な戻り値の使い分けを理解する (本書の方針も含む)。
- クロージャの基本的な構文と、環境の変数をキャプチャする能力を理解する。

---

## 5.1 Python/Go ではこうやっていた

Python や Go でも、関数はコードをまとめる基本的な単位でした。

- Python: `def` キーワードで関数を定義し、型ヒントで引数と戻り値の型を示すことができました。`lambda` 式で簡単な無名関数も作成できました。
- Go: `func` キーワードで関数を定義し、引数と戻り値の型は常に明示する必要がありました。Go も無名関数をサポートしています。

Rust の関数定義は Go に似ていますが、式指向の性質から、値の返し方にユニークな特徴があります。

## 5.2 関数の定義と呼び出し

Rust では `fn` キーワードを使って関数を定義します。引数の型と戻り値の型は、必ず明記する必要があります。

```rust
fn main() {
    another_function(5, 'h');
}

// 関数の定義
fn another_function(x: i32, unit_label: char) {
    println!("The measurement is: {}{}", x, unit_label);
}
```

関数名の命名規則は、変数名と同様に スネークケース (`snake_case`) が慣習です。

## 5.3 文 (Statement) と式 (Expression)

この違いを理解することは、Rust の戻り値を理解する上で非常に重要です。

- 文 (Statement): 何らかのアクションを実行しますが、値を返しません。`let` による変数宣言は文です。
  ```rust
  let y = 6; // これは文
  ```
- 式 (Expression): 値に評価され、結果を返します。`5 + 6` は `11` という値を返す式です。関数の呼び出しも式です。ブロック `{}` も式になり得ます。

```rust
fn main() {
    let y = {
        let x = 3;
        x + 1 // セミコロンがないことに注意！
    };

    println!("The value of y is: {}", y); // => 4
}
```
この例では、`{}` ブロック全体が `x + 1` の結果である `4` という値に評価され、その値が `y` に束縛されます。

ここが重要: 式の末尾にセミコロンを付けると、それは文に変わります。つまり、値を返さなくなります (技術的には `()` というユニット型を返しますが、これは今は「値を返さない」と考えて問題ありません)。

```mermaid
graph TD
    subgraph "コード要素"
        A["`let y = 6;`"] --> B{文<br>Statement};
        C["`5 + 6`"] --> D{式<br>Expression};
        E["`{ let x = 3; x + 1 }`"] --> D;
        F["`another_function()`"] --> D;
    end
    subgraph "特徴"
        B --> G[値を返さない<br>アクションを実行];
        D --> H[値を返す<br>結果に評価される];
    end
    I["`x + 1;` (セミコロンあり)"] -- セミコロンで --> B;
```

## 5.4 関数の戻り値：`return` vs 式

Rust の関数は、`->` の後に型を記述することで戻り値を指定できます。値を返す方法は 2 つあります。

### 1. `return` キーワード (本書・第 1 部での推奨)
他の多くの言語と同様に、`return` キーワードを使って明示的に値を返すことができます。

```rust
fn five() -> i32 {
    return 5;
}

fn main() {
    let x = five();
    println!("The value of x is: {}", x);
}
```

本書の方針: 企画書で述べた通り、本書の第 1 部 (第 1 章〜第 14 章) では、学習者の混乱を避けるために、常に関数の戻り値には `return` を明示的に使用します。これにより、他の言語の経験者が持つ「値を返すには `return` を書く」という直感と一致させ、学習をスムーズに進めます。

### 2. 関数の本体を式にする (暗黙の戻り値)

関数の本体が、セミコロンで終わらない最後の式である場合、その式の値が関数の戻り値として 暗黙的に 返されます。

```rust
// これは Rust の慣用的な書き方
fn plus_one(x: i32) -> i32 {
    x + 1 // セミコロンなし
}
```
この書き方は非常に簡潔ですが、セミコロンの有無で挙動が変わるため、初心者がつまずきやすいポイントでもあります。この慣用的な書き方については、基礎が固まった後の第 2 部で詳しく解説します。

## 5.5 クロージャ：環境をキャプチャする無名関数

クロージャは、変数に束縛できる無名関数です。定義された環境にある変数を キャプチャ して、後から使うことができるという強力な特徴があります。

```rust
fn main() {
    let x = 4;

    // `x` をキャプチャするクロージャを定義
    // 引数は `|` で囲み、型は推論されることが多い
    let equal_to_x = |z| z == x;

    let y = 4;

    assert!(equal_to_x(y));
}
```

この例では、クロージャ `equal_to_x` が、自身のスコープの外にある変数 `x` の値を「覚えて」います。

Python の `lambda` や Go の無名関数と似ていますが、Rust のクロージャは、変数をどのようにキャプチャするか (値をムーブするか、借用するかなど) をコンパイラが厳密に管理する点で、より安全性が高くなっています。クロージャの高度な使い方については、後の章で詳しく学びます。

## 5.6 まとめ

- ✓ 関数は `fn` で定義し、引数と戻り値の 型は必ず明記する。
- ✓ 式 は値を返し、文 は返さない。式の末尾にセミコロンを付けると文になる。
- ✓ 関数の戻り値は、`return` で明示的に返す方法と、最後の式で暗黙的に返す方法がある。
- ✓ 本書の方針: 第 1 部では、常に `return` を明示的に使用して分かりやすさを優先する。
- ✓ クロージャ は環境の変数をキャプチャできる無名関数。

---

文と式の違い、そして戻り値の扱いは、Rust のコードを読み書きする上での基本となります。特に `return` の省略は、慣れるまでは意識的に避けるのが懸命です。

次の章では、いよいよ Rust の核心であり、多くの初学者が壁と感じる「所有権」について、その仕組みを一つずつ丁寧に解き明かしていきます。
