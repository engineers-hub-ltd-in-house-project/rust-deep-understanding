# 第 6 章：所有権の基本

## この章のゴール
- 所有権が、ガベージコレクションに代わる Rust のメモリ管理方法であることを説明できる。
- スタックとヒープの基本的な違いと、どのようなデータがどちらに置かれるかを理解する。
- 所有権の 3 つのルールを暗唱できる。
- ムーブ (Move) セマンティクスと、それが `Copy` トレイトを持たない型でどのように発生するかを図解できる。
- `Copy` トレイトの役割と、どのような型が `Copy` を持つかを理解する。

---

## 6.1 なぜ所有権が必要なのか？

これまであなたが使ってきた Python や Go では、ガベージコレクタ (GC) がメモリ管理の大部分を自動的に行ってくれていました。GC は非常に便利ですが、実行時にどのメモリが不要になったかを判断するためのオーバーヘッドがあり、時にはプログラムの実行を一時停止 ("Stop the World") させてしまうこともあります。

C や C++ のような言語では、開発者が手動でメモリを確保 (`malloc`) し、解放 (`free`) する必要があります。これは最高のパフォーマンスを引き出せますが、解放漏れによるメモリリークや、解放済みのメモリにアクセスしてしまうダングリングポインタなど、深刻なバグの温床となってきました。

Rust は、これらとは全く異なる第 3 のアプローチを取ります。それが 所有権 (Ownership) です。

所有権は、コンパイラがコンパイル時に一連のルールをチェックすることで、GC なしでメモリ安全性を保証する 仕組みです。実行時のオーバーヘッドなしに、C/C++ のような手動メモリ管理で発生しがちなバグをコンパイル段階で完全に排除します。

```mermaid
graph TD
    subgraph メモリ管理
        A[手動管理<br>(C/C++)] --> B{パフォーマンス: ◎<br>安全性: △};
        C[ガベージコレクション<br>(Python/Go)] --> D{パフォーマンス: ◯<br>安全性: ◎};
        E[所有権<br>(Rust)] --> F{パフォーマンス: ◎<br>安全性: ◎};
    end
```

## 6.2 所有権の 3 つのルール

所有権システムの全体像は、以下の 3 つのシンプルなルールに基づいています。

1.  Rust の各値は、所有者 (Owner) と呼ばれる変数を一つだけ持つ。
2.  一度に存在できる所有者は一人だけ。
3.  所有者がスコープから外れたら、値は破棄 (ドロップ) される。

この 3 つのルールをコンパイラが厳密に適用することで、メモリの二重解放や解放後の使用といった問題が構造的に起こりえなくなるのです。

## 6.3 スタックとヒープ

所有権を理解するには、プログラムがメモリをどのように利用するか、スタックとヒープの違いを理解しておく必要があります。

- スタック (Stack):
  - 高速にアクセスできるメモリ領域。
  - データは後入れ先出し (LIFO) で管理される。
  - 関数の呼び出し時に確保され、関数終了時に自動的に解放される。
  - コンパイル時にサイズが確定している データ (`i32` のような数値型、`bool` など) が置かれる。

- ヒープ (Heap):
  - やや低速なメモリ領域。
  - データを格納する場所を OS に要求し、ポインタ (メモリ上の住所) を受け取る。
  - コンパイル時にサイズが不確定な、あるいはサイズが変わりうるデータ (`String` など) が置かれる。

所有権システムが主に管理するのは、この ヒープ 上のデータです。

## 6.4 所有権の核心：ムーブ (Move) セマンティクス

それでは、所有権のルールが実際にどのように機能するか見ていきましょう。ここでは、ヒープにデータを格納する `String` 型を例に取ります。

```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1; // s1 の所有権が s2 に「ムーブ」する
}
```

このコードは、Python や Go の経験者からすると、`s1` と `s2` が同じ文字列 "hello" を指すように見えるかもしれません。しかし、Rust では全く違うことが起こっています。

```mermaid
graph TD
    subgraph "let s1 = String::from(\"hello\");"
        A[Stack: s1] --> B[Heap: "hello"];
        A -- ptr --> B;
    end
    subgraph "let s2 = s1;"
        C[Stack: s1] --> D[<font color=red>INVALID</font>];
        E[Stack: s2] --> B;
        E -- ptr --> B
    end

    style D fill:#f9f,stroke:#333,stroke-width:2px
```
1.  `let s1 = ...` : `s1` はスタック上に作られ、ヒープ上の文字列データへのポインタ、長さ、容量を保持します。`s1` がヒープデータの 所有者 です。
2.  `let s2 = s1;` : ここで、`s1` が保持していたデータ (ポインタ等) が `s2` にコピーされます。ヒープ上のデータそのものはコピーされません。そして、ルール 2「一度に存在できる所有者は一人だけ」に基づき、`s1` はもはや無効 と見なされます。これが 所有権のムーブ (移動) です。

このムーブの後、`s1` を使おうとするとどうなるでしょうか？

```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1;

    println!("{}, world!", s1); // ❌ コンパイルエラー！
}
```

コンパイラは `borrow of moved value: s1` (ムーブされた値 `s1` を借用しようとしました) というエラーを出します。これにより、同じヒープデータを指す 2 つの変数が存在し、両方がスコープを抜ける際に二重にメモリを解放しようとする (二重解放バグ) 危険性を、コンパイル時に完全に防いでいるのです。

## 6.5 例外：`Copy` トレイト

では、なぜ第 3 章で見たような `i32` 型では、このようなムーブが起きなかったのでしょうか？

```rust
fn main() {
    let x = 5;
    let y = x; // `x` はムーブされない

    println!("x = {}, y = {}", x, y); // これは問題なく動作する！
}
```

これは、`i32` のようなコンパイル時にサイズが既知で、スタック上に完全にコピーできる単純な型が、`Copy` トレイト を実装しているためです。

`Copy` トレイトを持つ型は、代入時に所有権がムーブするのではなく、値が完全に「コピー」されます。ヒープ上のデータを持たないため、コピーのコストが非常に安価だからです。

`Copy` トレイトを持つ主な型:
- `i32`, `u64` などの全ての整数型
- `f32`, `f64` などの浮動小数点数型
- `bool`
- `char`
- `Copy` トレイトを持つ型のみで構成されるタプル `(i32, bool)`

`String` のような、ヒープにデータを確保する型は `Copy` トレイトを実装できません。もしデータの深いコピー (ディープコピー) が必要な場合は、`clone()` メソッドを明示的に呼び出す必要があります。

## 6.6 まとめ

- ✓ 所有権 は、GC なしでメモリ安全性を保証する Rust の革新的な仕組み。
- ✓ 3 つのルール (所有者は一人、など) がコンパイル時に強制される。
- ✓ ヒープにデータを持つ `String` のような型では、代入時に所有権が ムーブ し、元の変数は無効になる。
- ✓ スタックのみで完結する `i32` のような単純な型は `Copy` トレイト を持ち、代入時に値がコピーされる。

---

所有権は Rust の最も難解な部分と言われますが、同時に最も強力な機能でもあります。この「ムーブ」という概念が、今後のエラーメッセージを理解する鍵となります。

次の章では、所有権をムーブさせずに、一時的に値を使わせてもらう「借用」という、もう一つの重要な概念について学びます。
