# 第 13 章：イテレータとコレクション操作

## この章のゴール
- イテレータの概念と、その遅延評価の特性を理解する。
- `into_iter`, `iter`, `iter_mut` が所有権にどう影響するかを、エラーを通して体験する。
- `for` ループで書かれた処理を、`map` や `filter` を使ったイテレータチェーンに書き換えられる。
- `collect` を使ってイテレータからコレクションを生成できる。

---

## 13.1 「どのように」から「何を」へ

前の章で学んだ `for` ループは、コレクションの要素を一つずつ処理するための基本的な方法です。しかし、ループが複雑になるにつれ、「**どのように**（`for` でループして、`if` で条件分岐して、新しい `Vec` に `push` する）」という手続き的な実装の詳細が、「**何を**（偶数をフィルタして2倍にする）」という本来の目的を覆い隠してしまいがちです。

- **Python**: リスト内包表記や `map`, `filter` を使うことで、「何を」したいのかを宣言的に記述できました。
- **Go**: `for` ループで手続き的に記述するのが一般的でした。

Rustのイテレータは、Pythonのイテレータやリスト内包表記のように、「何を」したいのかを明確に表現するための強力なツールです。さらに、ゼロコスト抽象化の原則により、イテレータを使った高度な表現は、手で最適化した `for` ループと全く同じパフォーマンスの機械語にコンパイルされます。

```sh
cargo new iterators
```
でプロジェクトを作り、その威力を体験してみましょう。

## 13.2 イテレータの3つの形態と所有権

イテレータは、コレクションの各要素を順番に作り出すオブジェクトです。`for` ループは、実は内部でイテレータを使っています。`for item in collection` というコードは、暗黙的に `collection.into_iter()` を呼び出しているのです。

コレクションからイテレータを生成するには、主に3つの方法があり、それぞれ所有権の扱いが異なります。

- `into_iter()`: コレクションの所有権を奪い、各要素の値 (`T`) を生成する。イテレート後はコレクションがムーブしているので使えなくなる。
- `iter()`: コレクションの不変の参照を作り、各要素の不変参照 (`&T`) を生成する。
- `iter_mut()`: コレクションの可変の参照を作り、各要素の可変参照 (`&mut T`) を生成する。

### 試してみよう：イテレータで所有権をムーブさせる

`into_iter` がコレクションの所有権を本当に奪うのか、試してみましょう。

```rust
// src/main.rs

fn main() {
    let v1: Vec<i32> = vec![1, 2, 3];

    // v1.into_iter() は v1 の所有権をムーブする
    let v1_iter = v1.into_iter();

    // 以下の行のコメントを外すとコンパイルエラー！
    // v1 は v1_iter にムーブされた後なので使えない
    // println!("v1 is: {:?}", v1);
    
    for val in v1_iter {
        println!("Got: {}", val);
    }
}
```
[Rust Playgroundで試す](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&code=//%20src/main.rs%0A%0Afn%20main%28%29%20%7B%0A%20%20%20%20let%20v1%3A%20Vec%3Ci32%3E%20%3D%20vec%21%5B1%2C%202%2C%203%5D%3B%0A%0A%20%20%20%20//%20v1.into_iter%28%29%20%E3%81%AF%20v1%20%E3%81%AE%E6%89%80%E6%9C%89%E6%A8%A9%E3%82%92%E3%83%A0%E3%83%BC%E3%83%96%E3%81%99%E3%82%8B%0A%20%20%20%20let%20v1_iter%20%3D%20v1.into_iter%28%29%3B%0A%0A%20%20%20%20//%20%E4%BB%A5%E4%B8%8B%E3%81%AE%E8%A1%8C%E3%81%AE%E3%82%B3%E3%83%A1%E3%83%B3%E3%83%88%E3%82%92%E5%A4%96%E3%81%99%E3%81%A8%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%AB%E3%82%A8%E3%83%A9%E3%83%BC%EF%BC%81%0A%20%20%20%20//%20v1%20%E3%81%AF%20v1_iter%20%E3%81%AB%E3%83%A0%E3%83%BC%E3%83%96%E3%81%95%E3%82%8C%E3%81%9F%E5%BE%8C%E3%81%AA%E3%81%AE%E3%81%A7%E4%BD%BF%E3%81%88%E3%81%AA%E3%81%84%0A%20%20%20%20//%20println%21%28%22v1%20is%3A%20%7B%3A%3F%7D%22%2C%20v1%29%3B%0A%20%20%20%20%0A%20%20%20%20for%20val%20in%20v1_iter%20%7B%0A%20%20%20%20%20%20%20%20println%21%28%22Got%3A%20%7B%7D%22%2C%20val%29%3B%0A%20%20%20%20%7D%0A%7D)
`println!` の行のコメントを外して `cargo run` すると、`borrow of moved value: v1` エラーが発生します。`into_iter` を呼び出した時点で `v1` の所有権は `v1_iter` にムーブされたため、もはや `v1` にはアクセスできないのです。

一方で、`iter()` を使った場合は、`v1` の参照を借用するだけなので、イテレート後も `v1` は有効です。

```rust
fn main() {
    let v1: Vec<i32> = vec![1, 2, 3];
    let v1_iter = v1.iter(); // 不変の参照をイテレート

    // イテレート後も v1 は有効
    println!("v1 is still: {:?}", v1);
}
```
[Rust Playgroundで試す](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&code=fn%20main%28%29%20%7B%0A%20%20%20%20let%20v1%3A%20Vec%3Ci32%3E%20%3D%20vec%21%5B1%2C%202%2C%203%5D%3B%0A%20%20%20%20let%20v1_iter%20%3D%20v1.iter%28%29%3B%20//%20%E4%B8%8D%E5%A4%89%E3%81%AE%E5%8F%82%E7%85%A7%E3%82%92%E3%82%A4%E3%83%86%E3%83%AC%E3%83%BC%E3%83%88%0A%0A%20%20%20%20//%20%E3%82%A4%E3%83%86%E3%83%AC%E3%83%BC%E3%83%88%E5%BE%8C%E3%82%82%20v1%20%E3%81%AF%E6%9C%89%E5%8A%B9%0A%20%20%20%20println%21%28%22v1%20is%20still%3A%20%7B%3A%3F%7D%22%2C%20v1%29%3B%0A%7D)

## 13.3 イテレータアダプタ：宣言的なデータ変換

イテレータが真価を発揮するのは、イテレータアダプタと組み合わせた時です。これらは、イテレータを受け取って、何らかの変換を施した別のイテレータを返すメソッドです。

重要なのは、これらのアダプタは遅延評価されるということです。つまり、メソッドを呼び出した時点では何も計算は行われず、最終的に値を消費するメソッド（消費アダプタと呼ばれる）が呼ばれた時に初めて、すべての処理が一括で実行されます。これにより、不要な中間コレクションの生成を避け、非常に効率的なコードになります。

### 試してみよう：`for` ループをアダプタチェーンに書き換える

「数値のベクタから偶数だけを取り出し、それぞれを2倍した新しいベクタを作る」という処理を、まず `for` ループで書き、次にイテレータアダプタで書き換えてみましょう。

```rust
fn main() {
    let numbers = vec![1, 2, 3, 4, 5, 6];

    // --- for ループバージョン ---
    let mut doubled_evens_loop = Vec::new();
    for num in &numbers { // &numbers で不変参照を借用
        if num % 2 == 0 {
            doubled_evens_loop.push(num * 2);
        }
    }
    println!("Loop version: {:?}", doubled_evens_loop);


    // --- イテレータバージョン ---
    let doubled_evens_iter: Vec<_> = numbers
        .iter()      // 1. 各要素の不変参照(&i32)を持つイテレータを生成
        .filter(|&num| num % 2 == 0) // 2. 偶数のみをフィルタリング
        .map(|num| num * 2)     // 3. 各要素を2倍する
        .collect();  // 4. 結果を新しい Vec に収集（ここで初めて処理が実行される）

    println!("Iterator version: {:?}", doubled_evens_iter);
}
```
[Rust Playgroundで試す](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&code=fn%20main%28%29%20%7B%0A%20%20%20%20let%20numbers%20%3D%20vec%21%5B1%2C%202%2C%203%2C%204%2C%205%2C%206%5D%3B%0A%0A%20%20%20%20//%20---%20for%20%E3%83%AB%E3%83%BC%E3%83%97%E3%83%90%E3%83%BC%E3%82%B8%E3%83%A7%E3%83%B3%20---%0A%20%20%20%20let%20mut%20doubled_evens_loop%20%3D%20Vec%3A%3Anew%28%29%3B%0A%20%20%20%20for%20num%20in%20%26numbers%20%7B%20//%20%26numbers%20%E3%81%A7%E4%B8%8D%E5%A4%89%E5%8F%82%E7%85%A7%E3%82%92%E5%80%9F%E7%94%A8%0A%20%20%20%20%20%20%20%20if%20num%20%25%202%20%3D%3D%200%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20doubled_evens_loop.push%28num%20%2A%202%29%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%20%20%20%20println%21%28%22Loop%20version%3A%20%7B%3A%3F%7D%22%2C%20doubled_evens_loop%29%3B%0A%0A%0A%20%20%20%20//%20---%20%E3%82%A4%E3%83%86%E3%83%AC%E3%83%BC%E3%82%BF%E3%83%90%E3%83%BC%E3%82%B8%E3%83%A7%E3%83%B3%20---%0A%20%20%20%20let%20doubled_evens_iter%3A%20Vec%3C_%3E%20%3D%20numbers%0A%20%20%20%20%20%20%20%20.iter%28%29%20%20%20%20%20%20//%201.%20%E5%90%84%E8%A6%81%E7%B4%A0%E3%81%AE%E4%B8%8D%E5%A4%89%E5%8F%82%E7%85%A7%28%26i32%29%E3%82%92%E6%8C%81%E3%81%A4%E3%82%A4%E3%83%86%E3%83%AC%E3%83%BC%E3%82%BF%E3%82%92%E7%94%9F%E6%88%90%0A%20%20%20%20%20%20%20%20.filter%28%7C%26num%7C%20num%20%25%202%20%3D%3D%200%29%20//%202.%20%E5%81%B6%E6%95%B0%E3%81%AE%E3%81%BF%E3%82%92%E3%83%95%E3%82%A3%E3%83%AB%E3%82%BF%E3%83%AA%E3%83%B3%E3%82%B0%0A%20%20%20%20%20%20%20%20.map%28%7Cnum%7C%20num%20%2A%202%29%20%20%20%20%20//%203.%20%E5%90%84%E8%A6%81%E7%B4%A0%E3%82%922%E5%80%8D%E3%81%99%E3%82%8B%0A%20%20%20%20%20%20%20%20.collect%28%29%3B%20%20//%204.%20%E7%B5%90%E6%9E%9C%E3%82%92%E6%96%B0%E3%81%97%E3%81%84%20Vec%20%E3%81%AB%E5%8F%8E%E9%9B%86%EF%BC%88%E3%81%93%E3%81%93%E3%81%A7%E5%88%9D%E3%82%81%E3%81%A6%E5%87%A6%E7%90%86%E3%81%8C%E5%AE%9F%E8%A1%8C%E3%81%95%E3%82%8C%E3%82%8B%EF%BC%89%0A%0A%20%20%20%20println%21%28%22Iterator%20version%3A%20%7B%3A%3F%7D%22%2C%20doubled_evens_iter%29%3B%0A%7D)
`filter` や `map` といったアダプタをメソッドチェーンで繋げることで、処理の意図が「偶数を」「2倍する」という形で上から下に自然に読めるようになります。最終的に `.collect()` が呼ばれることで、イテレータは消費され、結果が `Vec` に集められます。

### 主要なアダプタ
- **イテレータアダプタ**（別のイテレータを返す）
  - `map`: 各要素に関数を適用して、新しい要素を生成する。
  - `filter`: 条件に合う要素だけを残す。
- **消費アダプタ**（値を返す）
  - `collect`: 結果をコレクションにまとめる。
  - `sum`: 要素の合計値を計算する。
  - `fold`: 畳み込み演算を行う (Python の `reduce` に相当)。
  - `find`: 条件に合う最初の要素を `Option` で返す。

## 13.4 まとめ

- イテレータは、コレクション操作を「どのように」から「何を」へ、手続き的なコードから宣言的なコードへと変える強力なツール。
- Rust のイテレータはゼロコスト抽象化により、パフォーマンスの犠牲がない。
- `.into_iter()` は所有権をムーブし、`.iter()` は不変の参照を、`.iter_mut()` は可変の参照を生成する。
- `map` や `filter` などのアダプタをチェーンし、最後に `collect` で結果を収集することで、効率的で読みやすいデータ変換パイプラインを構築できる。

---

これまでに Rust の基本的なデータ構造と、それらを効率的に操作する方法を学びました。次の章からは、より大きなプログラムを構築するための重要な概念、「抽象化」について掘り下げていきます。まずは、Rust のインターフェースとも言える「トレイト」の基本を学びましょう。

