# 第 13 章：イテレータとコレクション操作

## この章のゴール
- イテレータの概念と、その遅延評価の特性を理解する。
- `into_iter`, `iter`, `iter_mut` が所有権にどう影響するかを、エラーを通して体験する。
- `for` ループで書かれた処理を、`map` や `filter` を使ったイテレータチェーンに書き換えられる。
- `collect` を使ってイテレータからコレクションを生成できる。

---

## 13.1 「どのように」から「何を」へ

前の章で学んだ `for` ループは、コレクションの要素を一つずつ処理するための基本的な方法です。しかし、ループが複雑になるにつれ、「**どのように**（`for` でループして、`if` で条件分岐して、新しい `Vec` に `push` する）」という手続き的な実装の詳細が、「**何を**（偶数をフィルタして2倍にする）」という本来の目的を覆い隠してしまいがちです。

- **Python**: リスト内包表記や `map`, `filter` を使うことで、「何を」したいのかを宣言的に記述できました。
- **Go**: `for` ループで手続き的に記述するのが一般的でした。

Rustの **イテレータ** は、Pythonのイテレータやリスト内包表記のように、「何を」したいのかを明確に表現するための強力なツールです。さらに、**ゼロコスト抽象化** の原則により、イテレータを使った高度な表現は、手で最適化した `for` ループと全く同じパフォーマンスの機械語にコンパイルされます。

`cargo new iterators` でプロジェクトを作り、その威力を体験してみましょう。

## 13.2 イテレータの3つの形態と所有権

イテレータは、コレクションの各要素を順番に作り出すオブジェクトです。`for` ループは、実は内部でイテレータを使っています。`for item in collection` というコードは、暗黙的に `collection.into_iter()` を呼び出しているのです。

コレクションからイテレータを生成するには、主に3つの方法があり、それぞれ所有権の扱いが異なります。

- **`into_iter()`**: コレクションの **所有権を奪い**、各要素の値 (`T`) を生成する。イテレート後はコレクションがムーブしているので使えなくなる。
- **`iter()`**: コレクションの **不変の参照** を作り、各要素の不変参照 (`&T`) を生成する。
- **`iter_mut()`**: コレクションの **可変の参照** を作り、各要素の可変参照 (`&mut T`) を生成する。

### 試してみよう：イテレータで所有権をムーブさせる

`into_iter` がコレクションの所有権を本当に奪うのか、試してみましょう。

```rust
// src/main.rs

fn main() {
    let v1: Vec<i32> = vec![1, 2, 3];

    // v1.into_iter() は v1 の所有権をムーブする
    let v1_iter = v1.into_iter();

    // 以下の行のコメントを外すとコンパイルエラー！
    // v1 は v1_iter にムーブされた後なので使えない
    // println!("v1 is: {:?}", v1);
    
    for val in v1_iter {
        println!("Got: {}", val);
    }
}
```
`println!` の行のコメントを外して `cargo run` すると、`borrow of moved value: v1` エラーが発生します。`into_iter` を呼び出した時点で `v1` の所有権は `v1_iter` にムーブされたため、もはや `v1` にはアクセスできないのです。

一方で、`iter()` を使った場合は、`v1` の参照を借用するだけなので、イテレート後も `v1` は有効です。

```rust
fn main() {
    let v1: Vec<i32> = vec![1, 2, 3];
    let v1_iter = v1.iter(); // 不変の参照をイテレート

    // イテレート後も v1 は有効
    println!("v1 is still: {:?}", v1);
}
```

## 13.3 イテレータアダプタ：宣言的なデータ変換

イテレータが真価を発揮するのは、**イテレータアダプタ** と組み合わせた時です。これらは、イテレータを受け取って、何らかの変換を施した別のイテレータを返すメソッドです。

重要なのは、これらのアダプタは **遅延評価** されるということです。つまり、メソッドを呼び出した時点では何も計算は行われず、最終的に値を消費するメソッド（**消費アダプタ** と呼ばれる）が呼ばれた時に初めて、すべての処理が一括で実行されます。これにより、不要な中間コレクションの生成を避け、非常に効率的なコードになります。

### 試してみよう：`for` ループをアダプタチェーンに書き換える

「数値のベクタから偶数だけを取り出し、それぞれを2倍した新しいベクタを作る」という処理を、まず `for` ループで書き、次にイテレータアダプタで書き換えてみましょう。

```rust
fn main() {
    let numbers = vec![1, 2, 3, 4, 5, 6];

    // --- for ループバージョン ---
    let mut doubled_evens_loop = Vec::new();
    for num in &numbers { // &numbers で不変参照を借用
        if num % 2 == 0 {
            doubled_evens_loop.push(num * 2);
        }
    }
    println!("Loop version: {:?}", doubled_evens_loop);


    // --- イテレータバージョン ---
    let doubled_evens_iter: Vec<_> = numbers
        .iter()      // 1. 各要素の不変参照(&i32)を持つイテレータを生成
        .filter(|&num| num % 2 == 0) // 2. 偶数のみをフィルタリング
        .map(|num| num * 2)     // 3. 各要素を2倍する
        .collect();  // 4. 結果を新しい Vec に収集（ここで初めて処理が実行される）

    println!("Iterator version: {:?}", doubled_evens_iter);
}
```
`filter` や `map` といったアダプタをメソッドチェーンで繋げることで、処理の意図が「偶数を」「2倍する」という形で上から下に自然に読めるようになります。最終的に `.collect()` が呼ばれることで、イテレータは消費され、結果が `Vec` に集められます。

### 主要なアダプタ
- **イテレータアダプタ**（別のイテレータを返す）
  - `map`: 各要素に関数を適用して、新しい要素を生成する。
  - `filter`: 条件に合う要素だけを残す。
- **消費アダプタ**（値を返す）
  - `collect`: 結果をコレクションにまとめる。
  - `sum`: 要素の合計値を計算する。
  - `fold`: 畳み込み演算を行う (Python の `reduce` に相当)。
  - `find`: 条件に合う最初の要素を `Option` で返す。

## 13.4 まとめ

- イテレータは、コレクション操作を「どのように」から「何を」へ、手続き的なコードから宣言的なコードへと変える強力なツール。
- Rust のイテレータはゼロコスト抽象化により、パフォーマンスの犠牲がない。
- `.into_iter()` は所有権をムーブし、`.iter()` は不変の参照を、`.iter_mut()` は可変の参照を生成する。
- `map` や `filter` などのアダプタをチェーンし、最後に `collect` で結果を収集することで、効率的で読みやすいデータ変換パイプラインを構築できる。

---

これまでに Rust の基本的なデータ構造と、それらを効率的に操作する方法を学びました。次の章からは、より大きなプログラムを構築するための重要な概念、「抽象化」について掘り下げていきます。まずは、Rust のインターフェースとも言える「トレイト」の基本を学びましょう。

