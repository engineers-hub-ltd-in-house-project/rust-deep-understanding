# 第 13 章：イテレータとコレクション操作

## この章のゴール
- イテレータの概念と、その遅延評価の特性を理解する。
- `map`, `filter`, `fold` などの基本的なイテレータアダプタを使いこなせる。
- `collect` を使ってイテレータからコレクションを生成できる。
- `for` ループが内部でイテレータを使用していることを説明できる。

## 前章の復習
前の章では、`Vec`, `HashMap`, `String` といった基本的なコレクションについて学びました。これらのコレクションに要素を追加したり、アクセスしたりする方法を習得しました。

## なぜこれが必要なのか？
コレクション内の要素を一つずつ処理する `for` ループは非常に強力ですが、コードが冗長になりがちです。例えば、「数値のベクタから偶数だけを取り出し、それぞれを2倍した新しいベクタを作る」という処理を考えてみましょう。

`for` ループで書くと、以下のようになります。
```rust
let numbers = vec![1, 2, 3, 4, 5];
let mut doubled_evens = Vec::new();

for num in numbers {
    if num % 2 == 0 {
        doubled_evens.push(num * 2);
    }
}
// doubled_evens は [4, 8]
```
このコードは動作しますが、中間状態を保持するための `mut` 変数が必要だったり、処理の意図がループの内側を読まないと分からなかったりします。

イテレータを使うと、この処理をより宣言的で簡潔に記述できます。

## Python/Go ではこうやっていた
- **Python:** リスト内包表記や `map`, `filter` 関数を使って、同様の処理をエレガントに記述できました。
  ```python
  numbers = [1, 2, 3, 4, 5]
  doubled_evens = [x * 2 for x in numbers if x % 2 == 0]
  ```
- **Go:** イテレータの概念は言語に組み込まれておらず、伝統的な `for` ループを使うのが一般的でした。

## Rust ではこう書く: イテレータ
Rust のイテレータは、Python のリスト内包表記のように強力でありながら、**ゼロコスト抽象化**という重要な特徴を持っています。これは、イテレータを使った高級な表現が、手で書いた `for` ループと全く同じパフォーマンスの機械語にコンパイルされることを意味します。

先ほどの例をイテレータで書き直してみましょう。
```rust
let numbers = vec![1, 2, 3, 4, 5];
let doubled_evens: Vec<_> = numbers
    .iter()      // 1. イテレータを生成
    .filter(|&num| num % 2 == 0) // 2. 偶数のみをフィルタリング
    .map(|num| num * 2)     // 3. 各要素を2倍する
    .collect();  // 4. 結果を新しい Vec に収集
```

このコードは、処理の流れがメソッドチェーンとして上から下に自然に読めるため、非常に可読性が高いです。

### イテレータの仕組み
- `.iter()`: コレクションを消費せず、各要素への不変参照 (`&T`) を生成するイテレータを作ります。
- `.into_iter()`: コレクションを消費し、各要素の所有権 (`T`) をムーブするイテレータを作ります。
- `.iter_mut()`: 各要素への可変参照 (`&mut T`) を生成するイテレータを作ります。

イテレータ自体は**遅延評価**されます。つまり、`.collect()` のような消費メソッドが呼ばれるまで、実際の処理は何も行われません。これにより、不要な中間コレクションの生成を避け、非常に効率的なコードが生成されます。

### 主要なイテレータアダプタ
- `map`: 各要素に関数を適用して、新しい要素を生成します。
- `filter`: 条件に合う要素だけを残します。
- `fold`: 畳み込み演算を行います (Python の `reduce` に相当)。
- `find`: 条件に合う最初の要素を `Option` で返します。
- `any`: いずれかの要素が条件を満たすか (`bool`) を返します。
- `all`: すべての要素が条件を満たすか (`bool`) を返します。

## 実践例: `fold` で合計値を計算
```rust
let numbers = vec![1, 2, 3, 4, 5];
let sum = numbers.iter().fold(0, |accumulator, current_item| accumulator + current_item);
// sum は 15

// fold(初期値, |蓄積値, 現在の要素| ... )
```
これは `for` ループで合計を計算するよりも簡潔です。

## よくあるエラーと対処法
### エラー 1: `expected a different type`
**原因:** `map` や `filter` の後の型と、期待される型が一致していません。よくあるのは、`.iter()` を使ったため参照 (`&i32`) が渡ってきているのに、値 (`i32`) として扱おうとするケースです。
```rust
let numbers = vec![1, 2, 3];
// .map(|num| num * 2) だと num は &i32 なのでコンパイルエラー
let doubled: Vec<_> = numbers.iter().map(|&num| num * 2).collect();
//                                        ^ & をつけて値を取り出す (デリファレンス)
```
**解決法:** クロージャの引数で `&` を使ってパターンマッチするか、`*` を使って明示的にデリファレンスします。あるいは、`.into_iter()` を使って所有権ごと渡す方法もあります。

## 練習問題
### 問題 1: 文字列の処理
文字列のスライス (`&[&str]`) を受け取り、
1.  長さが 5 文字以上の単語のみをフィルタリングし、
2.  すべて大文字に変換し、
3.  結果を `Vec<String>` として返す関数を実装してください。

## この章のまとめ
- イテレータは、コレクション操作を宣言的で読みやすくするための強力なツール。
- Rust のイテレータはゼロコスト抽象化により、パフォーマンスの犠牲がない。
- `.iter()`, `.into_iter()`, `.iter_mut()` で異なる種類のイテレータを生成できる。
- `map`, `filter`, `fold` などのアダプタをチェーンして、複雑なデータ変換パイプラインを構築できる。

## 次の章へ
これまでに Rust の基本的なデータ構造と、それらを効率的に操作する方法を学びました。次の章からは、より大きなプログラムを構築するための重要な概念、「抽象化」について掘り下げていきます。まずは、Rust のインターフェースとも言える「トレイト」の基本を学びましょう。

