# 第13章：ゼロコスト抽象化：なぜ Rust は速いのか？

## この章のゴール
- 抽象化とそのトレードオフ（パフォーマンス低下）について説明できる。
- ゼロコスト抽象化が、そのトレードオフをどのように克服するかを説明できる。
- イテレータを例に、高レベルなコードが低レベルな機械語にコンパイルされる様子を説明できる。

---

## 13.1 プログラミングにおける「抽象化」とは？

これまでの章で、私たちは関数、構造体、トレイト、ジェネリクスといった多くの「抽象化」の道具を使ってきました。抽象化とは、複雑な詳細を隠蔽し、よりシンプルで高レベルなインターフェースを提供することで、プログラマがより本質的な問題に集中できるようにするテクニックです。

例えば、配列の要素にアクセスすることを考えてみましょう。

- 低レベルな表現: メモリの先頭アドレスから `(要素のサイズ * インデックス)` だけ離れた場所のデータを読み取る。
- 高レベルな（抽象化された）表現: `my_array[i]` と書くだけでアクセスできる。

ほとんどのプログラマは、日常的に後者の抽象化された表現を使います。これにより、メモリアドレスの計算ミスのような低レベルなバグを防ぎ、コードの意図を明確にできます。

## 13.2 抽象化の「コスト」

一般的に、こうした便利な抽象化には「コスト」が伴います。このコストは、主に実行時のパフォーマンス低下として現れます。

例えば、オブジェクト指向プログラミングにおける「ポリモーフィズム（多態性）」を考えてみましょう。JavaやPythonのような言語では、インターフェース（トレイトに似たもの）を介してメソッドを呼び出すと、実行時に「どのオブジェクトのメソッドを呼び出すべきか」を決定するための追加の処理（仮想テーブルのルックアップなど）が発生します。これは非常に強力な抽象化ですが、直接メソッドを呼び出す場合に比べてわずかなオーバーヘッドが生じます。

多くの高レベル言語は、「開発者の生産性のためなら、多少の実行時コストは許容する」という設計思想に立っています。

## 13.3 Rust の答え：ゼロコスト抽象化

ここで Rust のアプローチは異なります。Rust の核心的な設計思想の一つがゼロコスト抽象化 (Zero-Cost Abstraction) です。これは、次のように要約できます。

> 抽象化を使っても、それに対応する手書きの低レベルなコードと比べて、実行時のパフォーマンスが低下することはない。

言い換えると、「抽象化の便利さを、パフォーマンスを犠牲にすることなく享受できる」ということです。Rust は、この魔法のような特性を コンパイル時の処理 によって実現します。実行時に解決していたことを、可能な限りコンパイル時に解決してしまうのです。

## 13.4 具体例：イテレータの裏側

ゼロコスト抽象化の最も強力な例が、次章で学ぶ イテレータ です。

`Vec` の数値を合計する処理を考えてみましょう。

```rust
let numbers = vec![1, 2, 3, 4, 5];
let mut sum = 0;
for num in &numbers {
    sum += num;
}
println!("Sum: {}", sum);
```

このコードは、C言語の `for` ループのように、コンピュータが実行する処理を直接的に記述した低レベルなループです。このような単純なループは、コンパイラが「複数の計算を同時に実行する(ベクトル化)」「ループの判断コストを削減する(ループ展開)」といった変換を施しやすいため、非常に高速な機械語になります。これを、これから比較するための性能のベースラインと考えましょう。

ここからが Rust の面白いところです。イテレータを使うと、「どのように実行するか」 (`how`) を逐一指示する `for` ループとは対照的に、「何をしたいか」 (`what`) を直接的に表現する、宣言的なスタイルで同じ処理を書くことができます。

```rust
let numbers = vec![1, 2, 3, 4, 5];
let sum: i32 = numbers.iter().sum();
println!("Sum: {}", sum);
```

さらに、もっと複雑な処理も可能です。例えば、「偶数だけを2倍して合計する」処理を見てみましょう。

```rust
let numbers = vec![1, 2, 3, 4, 5];
let sum_of_doubled_evens: i32 = numbers
    .iter()
    .filter(|&&x| x % 2 == 0) // 偶数だけを残す
    .map(|&x| x * 2)          // 2倍する
    .sum();                   // 合計する
println!("Sum of doubled evens: {}", sum_of_doubled_evens); // -> 12 ( (2*2) + (4*2) )
```

`filter`, `map`, `sum` といったメソッドが連なっています。他の言語であれば、このような高レベルなメソッドチェーンは、中間的なデータ構造を生成したり、複数のループ処理に展開されたりして、パフォーマンスが低下する可能性があります。

しかし Rust では、コンパイラがこのコードを解析し、驚くべき最適化を行います。コンパイラは、このメソッドチェーン全体を、以下のような単一の、極めて効率的なループに変換してしまうのです。

```rust
// コンパイラが生成する機械語に相当するイメージ
let mut sum = 0;
for num in &numbers {
    if *num % 2 == 0 {   // filter の条件
        let doubled = *num * 2; // map の処理
        sum += doubled;         // sum の処理
    }
}
```

最終的に生成される機械語は、手で最適化した低レベルなコードと何ら遜色ないものになります。これがゼロコスト抽象化の力です。プログラマは、読みやすく、再利用性の高い高レベルな抽象化（`filter`や`map`）を使いながら、パフォーマンスについて心配する必要がなくなるのです。

## 13.5 まとめ

- 抽象化 は、複雑な詳細を隠蔽し、コードをシンプルにする強力なツールです。
- 伝統的に、抽象化には実行時のパフォーマンスコストが伴うことが多かった。
- Rust のゼロコスト抽象化は、コンパイラの強力な最適化により、抽象化のコストを実行時から取り除き、コンパイル時に解決します。
- イテレータ はその代表例であり、高レベルなメソッドチェーンが、手書きのループと同じくらい高速な機械語に変換されます。

このゼロコスト抽象化という原則こそが、Rust を「C++ のようなパフォーマンス」と「高レベル言語のような表現力」を両立させる、ユニークな言語たらしめている理由なのです。
