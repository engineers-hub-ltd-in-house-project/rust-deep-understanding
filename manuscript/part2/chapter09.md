# 第 9 章：構造体とメソッド

## この章のゴール
- `struct` キーワードを使って、関連するデータをまとめた独自のデータ型を定義できる。
- フィールドを持つ通常の構造体、タプル構造体、ユニット様構造体の 3 種類を使い分けられる。
- `impl` ブロックを使って、構造体にメソッドや関連関数を定義できる。
- メソッドの第一引数である `&self`, `&mut self`, `self` の違いと、所有権との関係を説明できる。

---

## 9.1 Python/Go ではこうやっていた

Python や Go では、複数のデータを一つにまとめるための仕組みがありました。

- Python: `class` を使って、データ (属性) とそのデータを操作するメソッドを一緒にカプセル化していました。`@dataclass` デコレータを使えば、より簡潔にデータ保持を目的としたクラスを定義できました。
- Go: `struct` を使って、異なる型のフィールドをまとめたデータ構造を定義していました。メソッドは、`func` キーワードとレシーバ引数を使って、`struct` とは別に定義するスタイルでした。

Rust のアプローチは、データ構造の定義 (`struct`) と、その振る舞いの定義 (`impl`) を分離するという点で、Go に似ています。

## 9.2 構造体の定義

構造体 (`struct`) は、関連する複数の値をまとめて意味のあるグループを作るためのカスタムデータ型です。Rust には主に 3 種類の構造体があります。

### 1. 通常の構造体
フィールドに名前を付けて定義する、最も一般的な構造体です。

```rust
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}

fn main() {
    let user1 = User {
        email: String::from("someone@example.com"),
        username: String::from("someusername123"),
        active: true,
        sign_in_count: 1,
    };
}
```
インスタンスを作成した後、フィールドの値にアクセスするにはドット (`.`) を使います (`user1.email`)。

### 2. タプル構造体
フィールド名はなく、型の定義だけを持つ構造体です。個々のフィールドに名前を付ける必要はないが、タプル全体としては名前を付けたい場合に便利です。

```rust
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

fn main() {
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
}
```

### 3. ユニット様構造体
フィールドを一切持たない構造体です。ある型に対してトレイトを実装したいが、その型に格納すべきデータがない場合に役立ちます (トレイトについては後の章で学びます)。

```rust
struct AlwaysEqual;

fn main() {
    let subject = AlwaysEqual;
}
```

## 9.3 メソッドの実装 (`impl`)

メソッドは関数と似ていますが、構造体 (や enum, トレイトオブジェクト) の文脈で定義される点が異なります。メソッドは、その構造体のインスタンスが何を行えるか、という「振る舞い」を定義します。

メソッドは `impl` (implementation の略) ブロックの中に定義します。

```mermaid
graph TD
    A[struct User { ... }] -- データ定義 --> C{User 型};
    B[impl User { ... }] -- 振る舞いを定義 --> C;
```

```rust
struct Rectangle {
    width: u32,
    height: u32,
}

// Rectangle 構造体のための impl ブロック
impl Rectangle {
    // メソッド area の定義
    // 第一引数は常に self
    fn area(&self) -> u32 {
        return self.width * self.height;
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "The area of the rectangle is {} square pixels.",
        rect1.area() // メソッド呼び出し
    );
}
```

### メソッドの第一引数: `self` と所有権

`impl` ブロック内の関数の第一引数は、常に `self` であり、これは `impl` の対象となっている型のインスタンスを指します。`self` には 3 つの主要な形式があり、所有権の扱いが異なります。

1.  `&self` (不変の借用): インスタンスを不変で借用します。メソッド内でインスタンスのデータを読み取るだけで、変更はしません。最も一般的な形式です。上記の `area` メソッドが良い例です。
2.  `&mut self` (可変の借用): インスタンスを可変で借用します。メソッド内でインスタンスの状態を変更したい場合に使います。
3.  `self` (所有権の取得): インスタンスの所有権を完全に取得します。このメソッドを呼び出すと、インスタンスはムーブされ、呼び出し元では使えなくなります。インスタンスを変換して別のものを返したい場合などに使われます。

## 9.4 関連関数

`impl` ブロックの中には、`self` を第一引数として取らない関数も定義できます。これを 関連関数 (associated function) と呼びます。メソッドがインスタンスの振る舞いを定義するのに対し、関連関数は構造体そのものに関連する機能を提供します。

これは、他の言語における「静的メソッド (static method)」と似ています。

関連関数は、構造体名と `::` 構文を使って呼び出します。構造体の新しいインスタンスを返すコンストラクタとしてよく使われます。

```