# 第 14 章：イテレータとコレクション操作

## この章のゴール
- イテレータの概念と、その遅延評価の特性を理解する。
- `iter()`, `into_iter()`, `iter_mut()` の 3 種類のイテレータを使い分け、所有権の挙動の違いを説明できる。
- イテレータアダプタ (`map`, `filter` など) を使って、コレクションを効率的かつ宣言的に操作できる。
- `collect` を使ってイテレータからコレクションを生成できる。

---

## 14.1 「どのように」から「何を」へ

前の章で学んだ `for` ループは、コレクションの要素を一つずつ処理するための基本的な方法です。しかし、ループが複雑になるにつれ、「**どのように**（`for` でループして、`if` で条件分岐して、新しい `Vec` に `push` する）」という手続き的な実装の詳細が、「**何を**（偶数をフィルタして2倍にする）」という本来の目的を覆い隠してしまいがちです。

```rust
let values = vec![1, 2, 3];

// 1. values.into_iter() が呼ばれ、イテレータが作られる
let mut iterator = values.into_iter();

// 2. iterator.next() が None を返すまでループする
while let Some(v) = iterator.next() {
    println!("Got: {}", v);
}
```
でプロジェクトを作り、その威力を体験してみましょう。

このおなじみの `for` ループは、コンパイラによって以下のようなコードに展開されます（これを **脱糖 (desugaring)** と呼びます）。

```rust
let values = vec![1, 2, 3];

// 1. values.into_iter() が呼ばれ、イテレータが作られる
let mut iterator = values.into_iter();

// 2. iterator.next() が None を返すまでループする
while let Some(v) = iterator.next() {
    println!("Got: {}", v);
}
```
でプロジェクトを作り、その威力を体験してみましょう。

つまり、`for` ループが機能するためには、ループ対象の型（この場合は `Vec<i32>`）がイテレータを返すための `IntoIterator` トレイトを実装している必要があるのです。

## 14.2 イテレータの3つの形態と所有権

イテレータは、コレクションの各要素を順番に作り出すオブジェクトです。`for` ループは、実は内部でイテレータを使っています。`for item in collection` というコードは、暗黙的に `collection.into_iter()` を呼び出しているのです。

1.  **`iter()`**: コレクションの **不変参照** (`&T`) をイテレートします。ループ後も元のコレクションは変更されずに残ります。
    ```rust
    let v1: Vec<i32> = vec![1, 2, 3];
    let v1_iter = v1.iter(); // 不変の参照をイテレート

    // イテレート後も v1 は有効
    println!("v1 is still: {:?}", v1);
    ```

2.  **`into_iter()`**: コレクションの **所有権をムーブ** (`T`) してイテレートします。ループ後は元のコレクションは使えなくなります。
    ```rust
    let v2: Vec<i32> = vec![1, 2, 3];
    for val in v2.into_iter() {
        println!("Got: {}", val);
    }
    // println!("{:?}", v2); // 💥 Error! v2はムーブされた後
    ```

3.  **`iter_mut()`**: コレクションの **可変参照** (`&mut T`) をイテレートします。ループ内で要素を変更することができます。
    ```rust
    let mut v3: Vec<i32> = vec![1, 2, 3];
    for val in v3.iter_mut() {
        *val += 1;
    }
    println!("v3 was mutated: {:?}", v3); // -> [2, 3, 4]
    ```

[Rust Playgroundで試す](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&code=fn%20main%28%29%20%7B%0A%20%20%20%20let%20v1%3A%20Vec%3Ci32%3E%20%3D%20vec%21%5B1%2C%202%2C%203%5D%3B%0A%20%20%20%20let%20v1_iter%20%3D%20v1.iter%28%29%3B%20//%20%E4%B8%8D%E5%A4%89%E3%81%AE%E5%8F%82%E7%85%A7%E3%82%92%E3%82%A4%E3%83%86%E3%83%AC%E3%83%BC%E3%83%88%0A%0A%20%20%20%20//%20%E3%82%A4%E3%83%86%E3%83%AC%E3%83%BC%E3%83%88%E5%BE%8C%E3%82%82%20v1%20%E3%81%AF%E6%9C%89%E5%8A%B9%0A%20%20%20%20println%21%28%22v1%20is%20still%3A%20%7B%3A%3F%7D%22%2C%20v1%29%3B%0A%7D)

## 14.3 イテレータアダプタ：宣言的なデータ変換

イテレータが真価を発揮するのは、イテレータアダプタと組み合わせた時です。これらは、イテレータを受け取って、何らかの変換を施した別のイテレータを返すメソッドです。

- **消費アダプタ (Consuming adaptors)**: イテレータの所有権を奪い、最終的な結果を返すメソッド。例: `sum()`, `collect()`。
- **イテレータアダプタ (Iterator adaptors)**: イテレータを受け取り、新しいイテレータを返すメソッド。遅延評価され、消費アダプタが呼ばれるまで実行されない。例: `map()`, `filter()`。

### 試してみよう：`map` と `collect`

`map` は、イテレータの各要素に関数を適用して、新しいイテレータを生成するアダプタです。`collect` は、そのイテレータから `Vec` などのコレクションを生成する消費アダプタです。

```rust
fn main() {
    let v1: Vec<i32> = vec![1, 2, 3];

    // v1.iter() は &i32 のイテレータを返す
    // map は、各要素に 1 を加えるクロージャを受け取り、新しいイテレータを生成
    // collect は、そのイテレータから新しい Vec を作成
    let v2: Vec<_> = v1.iter().map(|x| x + 1).collect();

    println!("v2: {:?}", v2); // -> [2, 3, 4]
}
```
でプロジェクトを作り、その威力を体験してみましょう。

この組み合わせにより、第13章で学んだ「ゼロコスト抽象化」が実現されます。`map` や `filter` をどれだけ連ねても、コンパイラが最適化して単一の効率的なループを生成してくれるのです。

## 14.4 まとめ

- イテレータは、コレクション操作を「どのように」から「何を」へ、手続き的なコードから宣言的なコードへと変える強力なツール。
- イテレータには `iter()` (`&T`)、`into_iter()` (`T`)、`iter_mut()` (`&mut T`) の 3 種類があり、所有権の扱いが異なる。
- イテレータアダプタ (`map`, `filter`) はイテレータを変換し、消費アダプタ (`sum`, `collect`) が最終的な値を生成する。
- イテレータのメソッドチェーンは、ゼロコスト抽象化により、手書きのループと同等のパフォーマンスにコンパイルされる。

---

次の章では、トレイトと並ぶもう一つの重要な抽象化機能、「ジェネリクス」と、この 2 つを組み合わせた「トレイト境界」について学びます。

