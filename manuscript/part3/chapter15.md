# 第 15 章：ジェネリクスとトレイト境界

## この章のゴール
- ジェネリックな関数と構造体を定義し、コードの重複を減らせるようになる。
- トレイト境界を使って、ジェネリックな型が持つべき振る舞いを制約できるようになる。
- `where` 句を使って、複雑なトレイト境界を読みやすく記述できる。
- 関連型 (Associated Types) の基本的な使い方を理解する。

## 前章の復習
前の章では、トレイトを使って異なる型に共通の振る舞いを定義する方法を学びました。`impl Trait` 構文を使い、トレイトを実装した任意の型を引数に取る関数を定義できることを見ました。

## なぜこれが必要なのか？
例えば、`i32` のスライスから最大の数を見つける関数と、`char` のスライスから最大の文字を見つける関数を考えてみましょう。ロジックは全く同じですが、型が違うため、2つの関数を書く必要があります。
```rust
fn largest_i32(list: &[i32]) -> i32 { /* ... */ }
fn largest_char(list: &[char]) -> char { /* ... */ }
```
これは非効率です。ジェネリクスを使うと、このようなコードの重複をなくし、型に対して汎用的なロジックを一度だけ書くことができます。

## Python/Go ではこうやっていた
- **Python:** 動的型付けなので、比較可能なオブジェクトであれば、同じ関数で処理できました。型ヒント (`typing.TypeVar`) を使ってジェネリックな意図を静的に示すことも可能です。
- **Go:** バージョン 1.18 でジェネリクスが導入されるまでは、`interface{}` を使うか、型ごとにコードを生成するなどの方法しかありませんでした。ジェネリクス導入後は、型パラメータを使って同様の汎用的な関数を記述できるようになりました。

## Rust ではこう書く: ジェネリクス
Rust のジェネリクスは、関数、構造体、列挙型、メソッドなどで使用できます。

### ジェネリックな関数
`fn function_name<T>(param: T) -> T` のように、山括弧 `<>` の中に型パラメータを宣言します。
```rust
fn largest<T: std::cmp::PartialOrd + Copy>(list: &[T]) -> T {
    let mut largest = list[0];
    for &item in list {
        if item > largest {
            largest = item;
        }
    }
    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];
    let result = largest(&number_list);
    println!("The largest number is {}", result); // 100

    let char_list = vec!['y', 'm', 'a', 'q'];
    let result = largest(&char_list);
    println!("The largest char is {}", result); // 'y'
}
```

### トレイト境界 (Trait Bounds)
上記の例の `T: std::cmp::PartialOrd + Copy` の部分がトレイト境界です。これは、「型 `T` は `PartialOrd` トレイト（比較が可能）と `Copy` トレイト（スタック上で簡単にコピー可能）を**両方**実装していなければならない」という制約をコンパイラに伝えています。

もしこの制約がないと、比較できない型（例えば構造体）が `largest` 関数に渡された場合にコンパイルエラーとなります。トレイト境界は、ジェネリックなコードの安全性を保証する重要な仕組みです。

### ジェネリックな構造体
構造体でも同様にジェネリクスを使えます。
```rust
struct Point<T, U> {
    x: T,
    y: U,
}

fn main() {
    let integer_point = Point { x: 5, y: 10 };
    let float_point = Point { x: 1.0, y: 4.0 };
    let mixed_point = Point { x: 5, y: 4.0 };
}
```

### `where` 句によるトレイト境界
トレイト境界が複雑になると、関数のシグネチャが読みにくくなることがあります。`where` 句を使うと、これらをきれいに整理できます。
```rust
// where句を使わない場合
fn some_function<T: Display + Clone, U: Clone + Debug>(t: &T, u: &U) -> i32 { /* ... */ }

// where句を使った場合
fn some_function<T, U>(t: &T, u: &U) -> i32
    where T: Display + Clone,
          U: Clone + Debug
{
    /* ... */
}
```

## 関連型 (Associated Types)
トレイト定義の中で、プレースホルダーとして使われる型を定義することができます。これにより、トレイトを実装する際に具体的な型を指定させることができます。イテレータの `Iterator` トレイトがその代表例です。
```rust
pub trait Iterator {
    type Item; // これが関連型

    fn next(&mut self) -> Option<Self::Item>;
}
```
この `Item` は、イテレータが返す要素の型を表します。`Vec<i32>` のイテレータを実装する場合、`Item` は `i32` になります。

## よくあるエラーと対処法
### エラー 1: `the trait ... is not implemented for T`
**原因:** ジェネリック関数内で、型 `T` が実装している保証のないトレイトのメソッド（例えば比較演算子 `>` など）を呼び出そうとしました。
**解決法:** 関数のシグネチャに適切なトレイト境界（例: `T: PartialOrd`）を追加してください。

## 練習問題
### 問題 1: ジェネリックな `sum` 関数
`Add` と `Default` トレイトを使って、数値のスライス（`&[T]`）の合計を計算するジェネリックな `sum` 関数を実装してください。`i32`, `f64` など、足し算が可能な任意の型で動作するようにしてください。

## この章のまとめ
- ジェネリクスは、関数やデータ構造を特定の型に縛られずに定義するための仕組み。
- トレイト境界は、ジェネリックな型が満たすべき振る舞いをコンパイラに伝え、コードの安全性を保証する。
- `where` 句を使うと、複雑なトレイト境界を読みやすく整理できる。
- 関連型は、トレイト内で使われるプレースホルダー型を定義するのに役立つ。

## 次の章へ
ジェネリクスとトレイトの組み合わせがいかに強力かを見てきました。Rust には、`Debug`, `Clone`, `PartialEq` など、非常に便利で広く使われている「標準トレイト」が多数用意されています。次の章では、これらの標準トレイトを使いこなし、`derive` 属性で簡単に実装する方法について学びます。
