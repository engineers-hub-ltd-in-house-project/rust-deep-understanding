# 第 17 章：スマートポインタ (Box, Rc, Arc)

## この章のゴール
- スマートポインタが、ポインタのように振る舞いつつ追加の機能を持つデータ構造であることを理解する。
- `Box<T>` を使ってデータをヒープに割り当て、その所有権を管理できるようになる。
- `Rc<T>` を使って、単一スレッド内でデータの複数の所有者を安全に管理できるようになる。
- `Arc<T>` を使って、複数スレッド間でデータの複数の所有者を安全に管理できるようになる。
- 循環参照がメモリリークを引き起こす可能性と、`Weak<T>` の役割を理解する。

## 前章の復習
前の章では、`derive` 属性を使って標準トレイトを簡単に実装する方法を学びました。これにより、自作の型にデバッグ、コピー、比較などの基本的な振る舞いを簡単に追加できるようになりました。

## なぜこれが必要なのか？
これまで `String` や `Vec` を使ってきましたが、これらは内部的にヒープメモリを利用しています。Rust では、このようなヒープへのデータ配置や、より高度な所有権のパターンを管理するために「スマートポインタ」という仕組みを提供しています。スマートポインタは、通常の参照 (`&`) とは異なり、データそのものの所有権を持つことができます。

## スマートポインタとは？
スマートポインタは、ポインタのように振る舞うデータ構造ですが、メタデータや追加の機能（例えば、参照カウントや自動的なメモリ解放処理など）を持っています。`String` や `Vec` もスマートポインタの一種です。この章では、特に汎用的なスマートポインタである `Box`, `Rc`, `Arc` に焦点を当てます。

### `Box<T>`: ヒープへの唯一の所有権
`Box<T>` は、データをスタックではなくヒープに確保するための最もシンプルな方法です。`Box` はデータへの唯一の所有者であり、`Box` がスコープを抜けると、ヒープ上のデータも自動的に解放（ドロップ）されます。

**いつ使うのか？**
1.  **コンパイル時にサイズが不明な型を扱う時:** 再帰的なデータ構造（例: 木構造のノード）などで利用します。
2.  **大きなデータを所有権ごと移動する時:** 大きなデータ（例: `[u8; 1_000_000]`）をスタック上でコピーするのは高コストですが、ヒープに置けばポインタ（`Box`）の移動だけで済み、高速です。

```rust
// 再帰的なリスト構造の例
enum List {
    Cons(i32, Box<List>), // List のサイズが不明なため Box が必要
    Nil,
}

let list = List::Cons(1, Box::new(List::Cons(2, Box::new(List::Nil))));
```

### `Rc<T>`: 参照カウントによる複数所有
`Rc<T>` (Reference Counting) は、単一スレッド内で、あるデータに対する複数の所有者を可能にするスマートポインタです。`Rc` は、自身が何個クローンされているかを常にカウントしており、このカウントがゼロになった時に初めてヒープ上のデータを解放します。
```rust
use std::rc::Rc;

let a = Rc::new(String::from("hello"));
println!("Count after creating a = {}", Rc::strong_count(&a)); // => 1

let b = Rc::clone(&a); // aをクローン。所有権はムーブしない
println!("Count after creating b = {}", Rc::strong_count(&a)); // => 2

{
    let c = Rc::clone(&a);
    println!("Count after creating c = {}", Rc::strong_count(&a)); // => 3
} // c がスコープを抜ける

println!("Count after c goes out of scope = {}", Rc::strong_count(&a)); // => 2
```
`Rc::clone(&a)` はデータ (`"hello"`) のディープコピーではなく、`Rc` へのポインタをコピーして参照カウントを1増やすだけの軽量な操作です。

**注意:** `Rc<T>` はスレッドセーフでは**ありません**。

### `Arc<T>`: アトミックな参照カウント
`Arc<T>` (Atomically Reference Counted) は、`Rc<T>` のスレッドセーフ版です。複数のスレッドから安全にデータを共有し、所有したい場合に使います。参照カウントの増減がアトミック操作（処理の途中で割り込まれることのない操作）で行われるため、`Rc<T>` よりもわずかにパフォーマンス上のオーバーヘッドがあります。
```rust
use std::sync::Arc;
use std::thread;

let a = Arc::new(String::from("hello"));

for _ in 0..10 {
    let a_clone = Arc::clone(&a);
    thread::spawn(move || {
        println!("{}", a_clone);
    });
}
```
`Arc::clone` を使って各スレッドに所有権の一部を与え、安全にデータを共有しています。

## 循環参照と `Weak<T>`
`Rc<T>` や `Arc<T>` を使うと、二つのインスタンスがお互いを所有し合う「循環参照」が発生することがあります。この場合、参照カウントが決してゼロにならず、メモリリークを引き起こします。
```rust
// 親が子を所有し、子も親を所有する循環参照の例
// このままではメモリリークする
```
この問題を解決するのが `Weak<T>` です。`Weak` は、所有権を持たずにデータへの参照を保持します。`Weak` 参照は参照カウントに影響を与えないため、循環参照を断ち切ることができます。データにアクセスしたい場合は、`.upgrade()` メソッドを呼び出し、それが成功した場合に一時的な `Rc` または `Arc` を取得します。

## よくあるエラーと対処法
### エラー 1: `T cannot be sent between threads safely`
**原因:** `Rc<T>` をスレッド間で渡そうとしました。
**解決法:** `Rc<T>` を `Arc<T>` に置き換えてください。

## 練習問題
### 問題 1: グラフ構造
`Rc` と `RefCell`（次の章で学びます）または `Mutex` を使って、複数のノードが他のノードを所有できるような単純なグラフデータ構造を実装してみてください。循環参照が発生しないように注意してください。

## この章のまとめ
- `Box<T>` は、データに対する唯一の所有権をヒープ上で実現する。
- `Rc<T>` は、シングルスレッド環境でデータへの複数の所有権を可能にする。
- `Arc<T>` は、マルチスレッド環境でデータへの複数の所有権を安全に可能にする。
- `Weak<T>` は、循環参照によるメモリリークを防ぐために使われる。

## 次の章へ
`Rc<T>` や `Arc<T>` を使ってデータを共有できるようになりましたが、共有したデータは不変でした。もし共有しているデータを変更したくなったらどうすればよいでしょうか？ 次の章では、「内部可変性」という概念と、それを実現する `RefCell<T>` や `Mutex<T>` といった型について学びます。
