# 第 16 章：標準トレイト (Debug, Clone, Copy, PartialEq, Eq 等)

## この章のゴール
- `derive` 属性を使って、広く使われる標準トレイトを自動的に実装できるようになる。
- `Debug` と `Display` の違いを理解し、適切に使い分ける。
- `Clone` と `Copy` の違いと、どのような場合に `Copy` を実装できるかを説明できる。
- `PartialEq`/`Eq` と `PartialOrd`/`Ord` の違いを理解する。

## 前章の復習
前の章では、ジェネリクスとトレイト境界について学びました。これにより、特定の型に縛られず、かつ型安全な汎用コードを書く方法を習得しました。

## なぜこれが必要なのか？
私たちが定義するほとんどの構造体や列挙型には、基本的な振る舞い（例えば、デバッグ出力したい、値を比較したい、コピーしたいなど）を持たせたいものです。これらの振る舞いは、Rust の標準ライブラリに「標準トレイト」として定義されています。

これらのトレイトを手動で実装することもできますが、多くの場合、その実装は定型的で自明です。そこで Rust は、`#[derive]` という属性を使って、これらの一般的なトレイトの実装をコンパイラに自動生成させる便利な機能を提供しています。

## `#[derive]` 属性
構造体や列挙型の定義の直前に `#[derive(...)]` と記述するだけで、コンパイラが括弧内に指定されたトレイトの実装コードを自動的に生成してくれます。
```rust
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
struct Point {
    x: i32,
    y: i32,
}
```
この一行を追加するだけで、`Point` 型はデバッグ出力、コピー、比較が可能になります。

## 主要な標準トレイト

### `Debug`: デバッグ出力
開発中に変数の内容を確認したい場合に便利です。`println!` マクロで `{:#?}` (見やすく整形) や `{:?}` (一行で表示) といったフォーマット指定子を使って出力できます。
```rust
#[derive(Debug)]
struct Person {
    name: String,
    age: u8,
}

let p = Person { name: "Alice".to_string(), age: 30 };
println!("{:#?}", p);
// Person {
//     name: "Alice",
//     age: 30,
// }
```

### `Display`: ユーザー向け出力
`Debug` が開発者向けであるのに対し、`Display` はエンドユーザーに見せるための、より洗練された出力を定義します。これは `derive` では自動実装できず、手動で実装する必要があります。
```rust
use std::fmt;

impl fmt::Display for Person {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{} ({})", self.name, self.age)
    }
}
// println!("{}", p); -> "Alice (30)"
```

### `Clone` と `Copy`
- `Clone`: `.clone()` メソッドを呼び出すことで、値の**ディープコピー**（ヒープ上のデータも含めた完全な複製）を明示的に作成します。
- `Copy`: `Clone` の特殊なケースで、値がスタック上だけで完結している場合に実装できます。`Copy` トレイトを実装した型の値は、代入時に自動的に**ビット単位のコピー**（ムーブではなく）が行われます。`i32` などのプリミティブ型はすべて `Copy` を実装しています。

**ルール:** 型が `Copy` であるためには、そのすべてのフィールドも `Copy` でなければなりません。`String` や `Vec` のようなヒープにデータを持つ型は `Copy` ではありません。

### `PartialEq` と `Eq`
- `PartialEq`: `==` 演算子による等価比較を可能にします。
- `Eq`: `PartialEq` に加えて、「すべての `a` に対して `a == a` が常に `true` である」という関係（全反射性）を満たすことを示します。浮動小数点数 (`f32`, `f64`) は `NaN == NaN` が `false` となるため `Eq` を実装できませんが、ほとんどの型は `PartialEq` と `Eq` の両方を `derive` できます。

### `PartialOrd` と `Ord`
- `PartialOrd`: `<` や `>` などの順序比較を可能にします。
- `Ord`: `PartialOrd` に加えて、「完全な順序関係」を持つことを示します。`f32` や `f64` は `NaN` の存在により `Ord` を実装できません。

## よくあるエラーと対処法
### エラー 1: `the trait bound `...` is not satisfied`
**原因:** 例えば、`assert_eq!` で比較しようとした構造体に `PartialEq` や `Debug` が実装されていませんでした。
**解決法:** 構造体の定義に `#[derive(PartialEq, Debug)]` を追加してください。

### エラー 2: `the trait `Copy` cannot be implemented for this type`
**原因:** `String` や `Vec` など、`Copy` を実装していないフィールドを持つ構造体に `#[derive(Copy)]` をつけようとしました。
**解決法:** `Copy` は諦めて `Clone` だけを `derive` し、必要な場面で `.clone()` を明示的に呼び出してください。

## 練習問題
### 問題 1: `derive` の追加
商品の情報を保持する `Product` 構造体を定義します。この構造体のインスタンスをデバッグプリント、クローン、比較（等価性）ができるように、適切な `derive` 属性を追加してください。
```rust
// #[derive(...)] // <- ここを埋める
struct Product {
    id: u32,
    name: String,
    price: f32,
}
```
**注意:** `price` が `f32` なので、`Eq` は `derive` できないはずです。どうなるか試してみましょう。

## この章のまとめ
- `#[derive]` 属性は、定型的なトレイト実装をコンパイラに自動生成させる便利な機能。
- `Debug` は開発者向け、`Display` はユーザー向けの出力を定義する。
- `Copy` はスタック上で完結する型のビット単位コピー、`Clone` はヒープを含むディープコピー。
- `PartialEq` と `Eq`、`PartialOrd` と `Ord` は、それぞれ比較の厳密さにおいて違いがある。

## 次の章へ
`String` や `Vec` のように、データをヒープに格納する型を見てきました。これらは「スマートポインタ」と呼ばれるものの一種です。次の章では、`Box`, `Rc`, `Arc` といった他のスマートポインタを探求し、Rust がどのようにして様々なメモリ管理のパターンを安全に実現しているかを学びます。
