# 第 16 章：標準トレイトと derive マクロ

## この章のゴール
- `#[derive]` 属性を使って、広く使われる標準トレイトを自動的に実装できるようになる。
- 「素の」`struct` がなぜプリントも比較もできないのかを、コンパイルエラーを通して体験する。
- `Debug`, `PartialEq`, `Clone`, `Copy` トレイトを `derive` することで、`struct` の能力が拡張されることを体験する。
- `Clone` (明示的なディープコピー) と `Copy` (暗黙的なビットコピー) の違いを説明できる。

---

## 16.1 問題設定：作った型が何もできない！

これまでに `struct` を使って独自の型を定義してきましたが、実は、定義しただけの「素の」`struct` は、ほとんど何もできません。デバッグのためにプリントすることも、等しいか比較することも、コピーすることすらできないのです。

`cargo new standard_traits` でプロジェクトを作り、この「何もできない」状態を体験してみましょう。

### 試してみよう：「素の」`struct` でエラーを起こす

```rust
// src/main.rs

struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p1 = Point { x: 1, y: 2 };
    let p2 = Point { x: 1, y: 2 };
    let p3 = p1;

    // 1. プリントしようとすると...？
    // println!("p1: {:?}", p1);

    // 2. 比較しようとすると...？
    // if p1 == p2 {
    //     println!("p1 and p2 are equal");
    // }

    // 3. コピー（のつもり）の後、元の変数を使おうとすると...？
    // println!("p3: {:?}", p3);
    // println!("p1 is moved: {:?}", p1);
}
```
このコードは、コメントアウトされた行を一つでも有効にすると、様々なコンパイルエラーを引き起こします。

1.  **プリントエラー**: `Point` doesn't implement `Debug` (`Point`は`Debug`トレイトを実装していません)
2.  **比較エラー**: binary operation `==` cannot be applied to type `Point` (`==`演算子は`Point`型に適用できません)
3.  **ムーブエラー**: `p1` の値は `p3` にムーブされているため、`p1` はもう使えません (`use of moved value: p1`)

これらの基本的な操作を可能にするのが、Rustの **標準トレイト** と、それを簡単に実装するための **`#[derive]`** マクロです。

## 16.2 解決策：`#[derive]` で能力を追加する

私たちが定義するほとんどの型には、基本的な振る舞いを持たせたいものです。これらの振る舞いは標準トレイトとして定義されており、`#[derive]` 属性を使えば、コンパイラに実装を自動生成させることができます。

先ほどの `Point` 構造体に、一つずつ能力を追加していきましょう。

```rust
#[derive(Debug, PartialEq, Copy, Clone)]
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p1 = Point { x: 1, y: 2 };
    let p2 = Point { x: 4, y: -3 };
    let p3 = p1;

    // 1. Debug を derive したので、プリントできる！
    println!("p1: {:?}", p1);

    // 2. PartialEq を derive したので、比較できる！
    if p1 == p2 {
        println!("p1 and p2 are equal");
    } else {
        println!("p1 and p2 are NOT equal");
    }

    // 3. Copy を derive したので、p1 はムーブされずコピーされる
    println!("p3: {:?}", p3);
    println!("p1 is still available: {:?}", p1);
}
```
この一行を追加するだけで、先ほどのエラーはすべて解決します。

## 16.3 主要な `derive` 可能トレイト

### `Debug`：開発者向けの表示
`println!("{:?}", value)` や `println!("{:#?}", value)` で構造体の内容をデバッグ表示できるようにします。ほぼすべての `struct` や `enum` で `derive` すべき、最も基本的なトレイトです。

### `PartialEq`, `Eq`：等価比較
`==` 演算子による等価比較を可能にします。ほとんどの場合、`PartialEq` を `derive` すれば十分です。(`Eq` はより厳密な等価性を示しますが、今は気にする必要はありません)

### `Clone`, `Copy`：複製

- **`Clone`**: `.clone()` メソッドを呼び出すことで、値の**ディープコピー**（ヒープ上のデータも含めた完全な複製）を明示的に作成できるようにします。`String` や `Vec` をフィールドに持つ構造体でも `derive` できます。

- **`Copy`**: `Clone` の特殊なケースで、値がスタック上だけで完結している場合にのみ実装できます。`Copy` を実装した型は、代入時に自動的に**ビット単位のコピー**が行われ、所有権はムーブしません。`i32` などのプリミティブ型はすべて `Copy` を実装しています。

**重要ルール**: 型が `Copy` であるためには、そのすべてのフィールドの型も `Copy` でなければなりません。`String` や `Vec` を持つ構造体は `Copy` にできません。

### 試してみよう：`Clone` だけを `derive` する

`String` を持つ構造体は `Copy` にできないことを体験してみましょう。

```rust
// Copy を外す必要がある。String は Copy ではないため。
#[derive(Debug, PartialEq, Clone)]
struct Person {
    name: String,
    age: u8,
}

fn main() {
    let p1 = Person { name: "Alice".to_string(), age: 30 };
    
    // let p2 = p1; // これは所有権のムーブになる
    // println!("{:?}", p1); // エラー！

    // 所有権をムーブさせたくない場合は、明示的に .clone() を呼ぶ
    let p2 = p1.clone();
    
    println!("p1: {:?}", p1); // p1 はまだ有効
    println!("p2: {:?}", p2); // p2 は p1 の複製
}
```

## 16.4 まとめ

- `#[derive]` 属性は、定型的なトレイト実装をコンパイラに自動生成させる便利なマクロ。
- **`Debug`**: 開発者向けに `{:#?}` で表示する能力。
- **`PartialEq`**: `==` で比較する能力。
- **`Clone`**: `.clone()` で明示的にディープコピーする能力。
- **`Copy`**: 代入時に暗黙的にコピーされる能力 (スタック上のデータのみを持つ型限定)。

---

`derive` マクロを使いこなすことで、ボイラープレートコードを大幅に削減し、本質的なロジックの記述に集中できます。

次の章では、`String` や `Vec` のようにデータをヒープに格納する「スマートポインタ」の世界を探求します。`Box<T>` を皮切りに、Rustがどのようにして様々なメモリ管理のパターンを安全に実現しているかを学びます。
