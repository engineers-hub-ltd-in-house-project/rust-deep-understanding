# Rust 書籍企画書

## 書籍タイトル (案)

**『Python/Go エンジニアのための実践 Rust 入門』**

副題: 「比較して学ぶ、現場で使える Rust の知恵」

**タイトルの特徴:**
- ターゲット読者が明確 (Python/Go 経験者)
- 「比較して学ぶ」アプローチを明示
- 「現場で使える」という実用性
- 「実践」というキーワード
- 3 年目エンジニアが次のステップに進むための一冊

---

## キャッチコピー案

```
・「Result 型が理解できない」を解消
・「トレイトが分からない」を解消
・「所有権の壁」を乗り越える
・「雰囲気だけ」で終わらせない深い理解
・1 章 1 概念で確実にステップアップ

こんな人におすすめ:
・Rust 入門書で挫折した経験がある
・他の言語は書けるのに Rust だけ理解できない
・現場で Rust を使う必要がある
・「わかったかんじ」では満足できない
・エラーが出ても自分で解決したい
```

---

## 1. 企画の背景・目的

### 1.1 Rust の現状
- システムプログラミング言語として注目度が高まっている
- 安全性とパフォーマンスを両立する次世代言語
- Linux Kernel、AWS、Cloudflare 等で採用が進む
- しかし「Rust は難しい」という評判が学習を妨げている

### 1.2 既存の入門書の問題点

現在市場にある Rust 入門書の多くは、以下の深刻な問題を抱えています:

#### 問題 1: 使わない要素を説明なしで登場させる

**具体例: Result 型の説明で**
```rust
let result: Result<i32, String> = Err("error".to_string());
println!("code: {}", result.unwrap_or(-1)); // => "code: -1"
```

**問題点:**
- エラーメッセージ `"error"` を定義しているのに使っていない
- なぜ `-1` なのか説明がない (`0` ではダメなのか？ 必須なのか？)
- 読者: 「わざわざエラーメッセージを作ったのに使わないって、何か意味があるの？」

**結果:**
- 表面的な理解しか得られない
- 実際のコードで応用できない
- 不必要な要素で混乱する

---

#### 問題 2: 1 ページに複数の概念を詰め込む

**具体例: エラーハンドリングの章で**

同じページ (見開き 2 ページ) で以下すべてを説明:
1. `match result { ... }`
2. `if let Ok(code) = result { ... }`
3. `unwrap_or(-1)`
4. `unwrap_or_else()` の言及
5. `and_then()` の説明
6. **さらに `?` 演算子まで**

```rust
// 同じページにこれらすべてが登場
result.unwrap_or(-1);
result.unwrap_or_else(|e| { ... });
result.and_then(func);
let code = result?;  // これも同時に！
```

**問題点:**
- 初心者はどれを使えばいいか分からない
- それぞれの違いが曖昧
- 使い分けの基準が不明確

**読者の心の声:**
「え、待って。`unwrap_or` もまだ理解してないのに、もう次の話？」

**結果:**
- すべてが中途半端な理解
- いざコードを書こうとすると何も書けない
- 選択肢が多すぎて選べない

---

#### 問題 3: 「慣れてきたら」を今紹介する矛盾

**具体例:**
本文: 「エラーハンドリングに慣れてきたら `?` 演算子を導入しましょう」

**→ なのに今のページで説明している！**

```rust
fn error_handling(result: Result<i32, String>) -> Result<i32, String> {
    let code = result?; // エラーの場合はここでreturn result;
    println!("code: {}", code);
    Ok(100)
}
```

さらに同じページで `let-else` 構文にも言及:
「let-else 構文を使う方法もあります。else 内の処理の最後では、break、return、panic! などで処理を中断させる必要があります」

**問題点:**
- 基礎が固まる前に応用を投げつける
- `?` 演算子は早期リターン、エラー伝搬、型の一致など複数の理解が必要
- `let-else` も別の高度な概念
- 「慣れてから」なら別の章で扱うべき

**結果:**
- 基礎も応用も中途半端
- `unwrap_or` の理解が不十分なまま次へ
- 深い理解が得られない

---

#### 問題 4: 説明なしで特殊構文を使用

**具体例: Box 型の説明で**
```rust
let byte_array = [b'h', b'e', b'l', b'l', b'o'];
print(byte_array);
```

**問題点:**
- `b'h'` (バイト文字リテラル) が説明なしで登場
- Box 型を説明したいのに、なぜバイト配列？
- 同時に登場する概念:
  * Box 型 (新しい)
  * バイト文字リテラル (説明なし)
  * サイズ不定な型 `[u8]` (難しい)
  * スライスと配列の違い (説明なし)

**初心者の疑問:**
- 「`b'h'` って何？ なぜ `b` がついてるの？」
- 「普通の `'h'` じゃダメなの？」
- 「Box 型を学びたいのに、なぜこんなに複雑な例？」

**結果:**
- Box 型も、バイト配列も、どちらも理解できない
- 複数の概念が混在して混乱
- シンプルな例 (`Box::new(5)`) から始めるべき

---

#### 問題 5: 「雰囲気だけつかんで」という敗北宣言

**具体例: トレイトの導出という章で**

本文: 「ここでは各トレイトの細かい意味には触れませんので、導出の雰囲気だけつかんでください」

**いきなり 6 つのトレイトを列挙:**
- Eq/PartialEq
- Ord/PartialOrd
- Copy
- Clone
- Debug
- Default

```rust
#[derive(Eq, PartialEq)]
struct A(i32);

#[derive(PartialEq, PartialOrd)]
struct B(i32);

#[derive(Copy, Clone)]
struct C;
```

**問題点:**
- トレイトとは何か → 説明なし
- Eq と PartialEq の違いは？ → 「雰囲気で」
- Copy と Clone の違いは？ → 「雰囲気で」
- なぜ Copy には Clone が必要？ → 「雰囲気で」

**これは入門書の敗北宣言:**
- 「理解させることを諦めました」という意味
- 「書き写して動けばいい」という態度
- 読者の知性を侮辱している

**結果:**
- すべてが曖昧なまま
- いざ使おうとすると何も分からない
- エラーが出ても対処できない

---

#### 問題 6: 暗黙的な return 省略

**具体例:**
```rust
fn validate_age(age: u32) -> Result<u32, String> {
    if age > 0 && age < 150 {
        Ok(age)  // ← return がない！
    } else {
        Err("年齢が範囲外です".to_string())  // ← return がない！
    }
}
```

**問題点:**
- 他の言語では `return` が必須なのに、説明なしで省略
- セミコロンの有無が意味を変えることを理解していない段階で使用
- 「Rust っぽい書き方」を優先して、理解を犠牲にしている

**初心者の混乱:**
- 「どこで値を返してるの？」
- 「2 章では `return` があったのに、5 章では消えてる。なぜ？」
- 「自分の書き方は間違ってる？」

**正しいアプローチ:**
- 第 1-10 章: 必ず `return` を明示
- 第 11 章「Rust の慣用的な書き方」: ここで初めて省略を導入
- 12 章以降: 両方の書き方を知った上で使用

---

#### 問題 7: 一貫性の欠如

**具体例:**
- 第 2 章: `return Ok(x);`
- 第 5 章: `Ok(x)` (突然 return が消える)
- 第 7 章: `return Ok(x);` (また return が戻る)

**用語の不統一:**
- 第 2 章: 「デフォルト値」
- 第 4 章: 「フォールバック値」
- 第 6 章: 「代替値」

**同じ概念なのに違う名前！**

**問題点:**
- 読者: 「デフォルト値とフォールバック値って別物？」
- スタイルの変更に説明がない
- 「正しい書き方」が分からず不安

**結果:**
- 内容ではなく「どう書くべきか」に気を取られる
- 自信を持ってコードが書けない
- 学習効率が大きく下がる

---

### 1.3 本書の目的

**「わかったかんじ」ではなく「深い理解」を提供し、現場で自信を持って Rust のコードが書ける人材を育成する**

### 1.4 なぜ今この本が必要なのか

**市場の声:**
- 「Rust 入門書を 3 冊読んだが、実際にコードが書けない」
- 「エラーが出ると対処できない」
- 「選択肢が多すぎて、どれを使えばいいか分からない」
- 「現場で使う自信がない」

**本書の解決策:**
- 1 つずつ確実に理解
- すべてに「なぜ」を説明
- 徹底的な一貫性
- 現場で使える深い理解

---

## 2. ターゲット読者

### 2.1 メインターゲット
- **他の言語での実務経験がある開発者**
  * Python/Go/JavaScript/Java など
  * 実務経験 2 年以上
  * 基本的なプログラミング概念は理解している

- **Rust で挫折した経験がある人**
  * 入門書を読んだが理解できなかった
  * 「Rust は難しい」と感じている
  * もう一度チャレンジしたい

- **現場で Rust を使う必要がある人**
  * 会社で Rust 導入が決まった
  * システムプログラミングに興味がある
  * パフォーマンスが必要なプロジェクト

### 2.2 セカンダリターゲット
- 既存の Rust 本で学んだが、実際にコードを書く自信がない人
- チームで Rust を導入したいが、教育方法に悩んでいる技術リーダー
- より深く Rust を理解したい中級者

### 2.3 読者の共通する悩み・ペインポイント

**技術的な悩み:**
- 「所有権が理解できない」
- 「borrow チェッカーのエラーが解決できない」
- 「Result/Option の使い分けが分からない」
- 「トレイトシステムが複雑すぎる」

**学習上の悩み:**
- 「書き写せば動くが、自分で書けない」
- 「エラーメッセージの意味が分からない」
- 「いつどの書き方を使えばいいか分からない」
- 「『雰囲気で』と言われても困る」

**キャリア上の悩み:**
- 「現場で Rust を使う自信がない」
- 「チームに教えられるレベルに達していない」
- 「Rust を習得してキャリアアップしたい」

---

## 3. 本書の特徴 (差別化ポイント)

### 3.1 徹底的な一貫性

**すべての章で同じスタイルを貫く**

**コーディングスタイルの一貫性:**
```rust
// 第 1 部 (第 1-10 章): 必ず return を明示
fn get_value() -> Result<i32, String> {
    return Ok(100);  // 必ず return
}

fn process(x: i32) -> Result<i32, String> {
    if x > 0 {
        return Ok(x);  // 必ず return
    } else {
        return Err("エラー".to_string());  // 必ず return
    }
}

// 第 11 章「Rust の慣用的な書き方」で初めて変更を導入
// 「実は、Rust では最後の式の return は省略できます」
fn get_value_idiomatic() -> Result<i32, String> {
    Ok(100)  // return 省略 (ここで初めて)
}
```

**用語の一貫性:**
- 「デフォルト値」なら最後まで「デフォルト値」
- 略称を使う場合は最初に必ず定義
- 用語集を巻末に用意

**説明レベルの一貫性:**
- 第 1-10 章: 丁寧な説明、豊富なコメント
- 突然難しくならない
- 前章の知識だけで理解できる

**効果:**
- 読者: 「この書き方で正しい」という安心感
- 内容に集中できる
- 自信を持ってコードが書ける

---

### 3.2 1 章 1 概念の徹底

**絶対に詰め込まない**

**エラーハンドリングの例:**
- **第 5 章: `match` だけ**
  * Result 型の基本
  * Ok/Err パターンマッチ
  * 豊富な練習問題
  
- **第 6 章: `unwrap_or` だけ**
  * エラー時のデフォルト値
  * デフォルト値の選び方
  * 使い所の明確化

- **第 7 章: `unwrap_or_else` だけ**
  * `unwrap_or` との違い
  * エラー内容を使う場合
  * ログ記録の実例

- **第 8 章: 実践練習**
  * ここまでの知識で実用的なコード
  * 複数のパターンを組み合わせる
  * 自分で判断して適切な方法を選ぶ

- **第 12 章: `and_then` (後の章で)**
  * 前提: Result 型を完全に理解している
  * エラーの連鎖
  * map, map_err との違い

- **第 15 章: `?` 演算子 (さらに後の章で)**
  * 前提: 関数の戻り値型を理解
  * エラー伝搬
  * 早期リターン

**各章の構成:**
1. **なぜこの概念が必要なのか** (動機付け)
2. **基本的な使い方** (シンプルな例)
3. **前の方法との違い** (比較表)
4. **使い分けの基準** (明確な基準)
5. **豊富な練習問題** (手を動かす)

**効果:**
- 確実な理解
- 使い分けの基準が明確
- 段階的なスキルアップ
- 「選択肢が多すぎて選べない」問題の解消

---

### 3.3 深い理解を促す説明

**「雰囲気だけ」「おまじない」という言葉を絶対に使わない**

**代わりに:**
- すべての概念に「なぜ」を説明
- 表面的な理解で終わらせない
- 読者の知性を信頼する
- 難しいものは正直に「難しい」と認める

**比較表・図解・実例を豊富に使用**

**例: unwrap_or の使い分け**
| 状況 | 使うメソッド | 理由 | 具体例 |
|------|------------|------|--------|
| エラー内容を無視して良い | `unwrap_or(0)` | シンプル | HTTP ステータス |
| エラー内容をログに記録したい | `unwrap_or_else(\|e\| {...})` | エラー情報が必要 | API 呼び出し |
| デフォルト値の計算コストが高い | `unwrap_or_else(\|\| expensive())` | 遅延評価 | DB クエリ |

**具体例の選び方:**
- 最もシンプルなデータ型 (整数、文字列)
- 実用的なシナリオ (HTTP ステータス、ファイル読み込み)
- 段階的に複雑化
- 説明なしの特殊構文は使わない
- 複数の概念を混ぜない

**例: Box 型の説明**

**悪い例 (既存書):**
```rust
let byte_array = [b'h', b'e', b'l', b'l', b'o'];  // b'h' って何？
```

**良い例 (本書):**
```rust
// 第 1 段階: シンプルな例
let x = Box::new(5);  // 整数だけ
println!("値: {}", *x);

// 第 2 段階: なぜ Box が必要か
struct LargeData { data: [i32; 1000] }  // 大きなデータ
let boxed = Box::new(large);  // コピーを避ける

// 第 3 段階: サイズ不定な型 (後の章で)
let slice: Box<[i32]> = Box::new([1, 2, 3]);

// 第 4 段階: バイト配列 (さらに後の章で)
let bytes = b"hello";  // ← ここで初めてバイト文字リテラルを説明
```

**効果:**
- 本質的な理解
- 応用が効く知識
- エラー対処能力
- 現場で自信を持って使える

---

### 3.4 段階的な難易度設計

**3 部構成で確実にステップアップ**

**第 1 部: 基礎編 (第 1-14 章) - しつこく、確実に**
- 最もシンプルな形で概念を導入
- 明示的な書き方を徹底 (必ず `return` を書く)
- 豊富な練習で完全に定着
- 各章に「よくある間違い」セクション

**到達目標:**
- Result/Option を自信を持って扱える
- 基本的なエラーハンドリングができる
- 簡単な CLI ツールが書ける

**第 2 部: 応用編 (第 15-25 章) - 慣用的な書き方へ**
- 基礎が完全に固まってから
- 第 15 章で明示的に「書き方の変更」を導入
- 慣用的な書き方の理由を説明
- 複雑な組み合わせ

**到達目標:**
- Rust らしいコードが書ける
- トレイトシステムを理解している
- エラー処理の最適な方法を選べる

**第 3 部: 実践編 (第 26 章-) - 現場で使える**
- 実際のアプリケーション開発
- 第 1 部・第 2 部の知識だけで理解できる
- 現場で使えるパターン
- パフォーマンス最適化

**到達目標:**
- 現場で Rust プロジェクトに参加できる
- チームメンバーに教えられる
- 自信を持って Rust を選択できる

---

### 3.5 実践的な例のみ - 無駄を排除

**無駄な要素を徹底的に排除**

**原則:**
- 使わない変数は定義しない
- すべてのコードに意味がある
- 実際のユースケースから逆算

**悪い例の排除:**

**・ エラーメッセージを使わない例**
```rust
// これはダメ
let result = Err("error".to_string());  // 使わないのに定義
println!("{}", result.unwrap_or(-1));   // エラーメッセージを捨てる
```

**・ 正しい例**
```rust
// シンプルに
let result: Result<i32, String> = Ok(200);
println!("{}", result.unwrap_or(0));

// エラーメッセージを使う場合
match result {
    Ok(code) => println!("成功: {}", code),
    Err(e) => println!("エラー: {}", e),  // ちゃんと使う
}
```

**例の選び方の基準:**

**・ 良い例の特徴:**
- 整数や文字列などシンプルなデータ
- 実用的なシナリオ (HTTP ステータス、ファイル I/O)
- 1 つの概念だけに集中
- 読者が自分のコードに応用できる

**・ 避けるべき例:**
- 説明なしの特殊構文 (`b'h'` など)
- 複数の概念を混ぜた例
- 「カッコいい」が理解しにくい例
- 実用性のない複雑な例

---

### 3.6 体験を通した学習サイクルの提供

本書は、単に知識を解説するだけでなく、読者が自らの手で試し、失敗し、理解する「体験的な学習サイクル」を提供することを最大の特徴とします。

- **「まず動かす」文化の醸成**: すべての概念説明は「まず、このコードを Rust Playground で実行してみてください」という呼びかけから始まります。読者はまず体験し、そこから生まれた疑問を解説で解消していきます。
- **エラーとの対話を促す**: 「`mut` を外してコンパイルエラーを起こしてみましょう」「わざと間違った型を渡してみましょう」といった「試してみよう」コーナーを豊富に設け、コンパイラとの対話を通じて学ぶ機会を積極的に作ります。エラーメッセージは罰ではなく、最高の学習教材であると位置づけます。
- **能動的な知識構築**: 一方的な説明に終始せず、問いかけや小さな課題を挟むことで、読者が常に考え、手を動かしながら読み進めることを促します。

このアプローチにより、「読んだけど書けない」という入門書にありがちな問題を根本的に解決し、読了後には「自分の力でエラーを解決し、コードを書ける」状態になることを保証します。

---

## 4. 章構成 (案)

### 本書の構成方針

**Python/Go 3 年目エンジニアを対象に:**
- 基本的なプログラミング概念は既知として簡潔に
- Python/Go との比較を各章に含める
- Rust の特徴的な部分 (所有権、借用、トレイト) に重点
- 実践的なプロジェクトで知識を定着
- 現場で必要な要素を網羅

**各章の構成テンプレート:**
```markdown
# 第 X 章: [タイトル]

## Python/Go ではこうやっていた
[既存の知識を確認]

## Rust ではこう書く
[新しい書き方を学ぶ]

## なぜ Rust はこう設計されているのか
[設計思想を理解]

## 実践例
[実際のユースケース]

## よくあるエラーと対処法
[躓きポイントを先回り]

## 練習問題
[手を動かして定着]
```

---

### 第 0 部: 導入編 (2 章)

#### 第 1 章: なぜ Python/Go エンジニアが Rust を学ぶのか
- **目的:** Rust を学ぶモチベーション、実務での位置づけ
- Python/Go の強みと限界
- Rust が解決する問題 (パフォーマンス、メモリ安全性、並行性)
- いつ Rust を選ぶべきか、いつ選ばないべきか
- 学習ロードマップの提示
- **比較:** Python/Go と Rust のパフォーマンス比較
- **成果物:** なし (読み物)

#### 第 2 章: 開発環境のセットアップ
- **目的:** 快適な開発環境を整える
- Rust のインストール (rustup)
- **CLI REPL の導入 (`evcxr`)**: 小さなコードを即座に試すための対話的実行環境をセットアップする
- エディタ/IDE の設定 (VS Code, IntelliJ IDEA)
- Cargo の基本 (プロジェクト作成、ビルド、実行)
- rust-analyzer の導入
- デバッガの設定
- **比較:** pip/venv vs Cargo、go mod vs Cargo
- **成果物:** Hello World プロジェクト

---

### 第 1 部: Rust の基礎 (6 章) - しつこく、確実に

#### 第 3 章: 変数と型システム
- **目的:** Rust の型システムを理解する
- 変数宣言 (let, mut)
- 基本型 (整数、浮動小数点、bool, char)
- 型推論とアノテーション
- シャドーイング
- 定数と static 変数
- **比較:** 
  * Python: 動的型付け、型ヒント
  * Go: 明示的型宣言、:= 演算子
  * Rust: 強い静的型付け、型推論
- **よくあるエラー:** 不変変数への代入、型の不一致
- **練習問題:** 温度変換プログラム、型変換の練習

#### 第 4 章: 制御構文とパターンマッチング
- **目的:** Rust の制御フローをマスターする
- if 式 (式であることの重要性)
- loop, while, for
- range とイテレータの基礎
- パターンマッチング (match)
- if let と while let
- **比較:**
  * Python: if 文、for-in、while
  * Go: if, for (while なし)、switch
  * Rust: すべてが式、強力な match
- **よくあるエラー:** match 網羅性、パターンの順序
- **練習問題:** FizzBuzz、簡単な電卓

#### 第 5 章: 関数とクロージャ
- **目的:** 関数とクロージャを使いこなす
- 関数の定義と呼び出し
- 引数と戻り値
- 式と文の違い (return 省略の理解)
- クロージャの基本
- 関数ポインタとクロージャの違い
- **比較:**
  * Python: def、lambda、デコレータ
  * Go: func、無名関数
  * Rust: fn、クロージャの柔軟性
- **よくあるエラー:** 戻り値の型、セミコロンの有無
- **練習問題:** 高階関数の実装、map/filter/reduce

#### 第 6 章: 所有権の基本
- **目的:** Rust の最も重要な概念を理解する
- 所有権とは何か
- スタックとヒープ
- ムーブセマンティクス
- Copy trait と Clone trait
- ドロップと RAII
- **比較:**
  * Python: ガベージコレクション、参照カウント
  * Go: ガベージコレクション
  * Rust: コンパイル時のメモリ管理
- **なぜ Rust はこう設計されているのか:** メモリ安全性とパフォーマンスの両立
- **よくあるエラー:** value moved、use after move
- **練習問題:** 文字列操作、ベクタの所有権

#### 第 7 章: 借用と参照
- **目的:** 参照を安全に使う
- 不変参照と可変参照
- 借用規則 (複数の不変参照 or 1 つの可変参照)
- ダングリング参照の防止
- スライス型
- **比較:**
  * Python: すべてが参照 (オブジェクトへのポインタ)
  * Go: ポインタと値、明示的な * と &
  * Rust: 借用チェッカーによる安全性保証
- **よくあるエラー:** mutable borrow while immutable borrow exists
- **練習問題:** 配列のソート、文字列の分割

#### 第 8 章: ライフタイムの理解
- **目的:** ライフタイムアノテーションをマスターする
- ライフタイムとは何か
- ライフタイム省略規則
- 構造体のライフタイム
- 'static ライフタイム
- ライフタイムとジェネリクスの関係
- **比較:**
  * Python/Go: ライフタイムの概念なし (GC 任せ)
  * Rust: コンパイラによるライフタイム検証
- **なぜ Rust はこう設計されているのか:** ダングリング参照の完全な防止
- **よくあるエラー:** lifetime mismatch、borrowed value does not live long enough
- **練習問題:** 参照を返す関数、複雑なライフタイム

---

### 第 2 部: Rust のデータ構造 (5 章)

#### 第 9 章: 構造体とメソッド
- **目的:** カスタムデータ型を作成する
- 構造体の定義 (struct)
- タプル構造体とユニット構造体
- メソッドの実装 (impl)
- 関連関数 (静的メソッド)
- 構造体の更新構文
- **比較:**
  * Python: class、@dataclass
  * Go: struct、メソッド (レシーバ)
  * Rust: struct + impl、所有権を考慮した設計
- **練習問題:** ユーザー管理システム、図形の面積計算

#### 第 10 章: 列挙型と Option
- **目的:** 列挙型と Option を使いこなす
- 列挙型 (enum) の定義
- パターンマッチングと enum
- Option<T> の理解
- None の処理 (match, if let, unwrap_or 等)
- **比較:**
  * Python: Enum、None との違い
  * Go: iota、nil との違い
  * Rust: タグ付きユニオン、型安全な null
- **なぜ Rust はこう設計されているのか:** null 参照の排除
- **よくあるエラー:** unwrap によるパニック
- **練習問題:** 設定ファイルの読み込み、オプショナルな値の処理

#### 第 11 章: Result 型とエラーハンドリング
- **目的:** 堅牢なエラーハンドリングを実装する
- Result<T, E> の理解
- match によるエラー処理
- unwrap_or でデフォルト値
- unwrap_or_else でエラー情報を使う
- ? 演算子によるエラー伝搬
- カスタムエラー型の作成
- thiserror と anyhow クレート
- **比較:**
  * Python: try-except、raise
  * Go: error 型、複数戻り値
  * Rust: Result 型、型安全なエラー処理
- **なぜ Rust はこう設計されているのか:** 例外なし、明示的なエラー処理
- **よくあるエラー:** Result<T, E> の型不一致
- **練習問題:** ファイル読み込み、HTTP リクエスト

#### 第 12 章: コレクション (Vec, HashMap, String)
- **目的:** 標準コレクションを使いこなす
- Vec<T>: 動的配列
- HashMap<K, V>: 連想配列
- String: UTF-8 文字列
- &str と String の違い
- イテレータとの組み合わせ
- **比較:**
  * Python: list、dict、str
  * Go: slice、map、string
  * Rust: Vec、HashMap、String、所有権を考慮
- **よくあるエラー:** index out of bounds、key not found
- **練習問題:** 単語カウンター、簡単な DB (HashMap)

#### 第 13 章: イテレータとコレクション操作
- **目的:** 関数型プログラミングのスタイルを学ぶ
- イテレータの基本
- map、filter、fold (reduce)
- collect、find、any、all
- イテレータチェーン
- カスタムイテレータの実装
- **比較:**
  * Python: リスト内包表記、map/filter/reduce
  * Go: for ループ (イテレータなし)
  * Rust: ゼロコスト抽象化のイテレータ
- **なぜ Rust はこう設計されているのか:** パフォーマンスと表現力の両立
- **練習問題:** データ変換パイプライン、CSV パーサー

---

### 第 3 部: 抽象化とコード再利用 (5 章)

#### 第 14 章: トレイトシステム入門
- **目的:** トレイトの概念を理解する
- トレイトとは何か
- トレイトの定義と実装
- トレイトメソッドとデフォルト実装
- トレイト境界
- **比較:**
  * Python: ABC (抽象基底クラス)、Protocol
  * Go: interface (暗黙的実装)
  * Rust: trait (明示的実装)
- **練習問題:** カスタムトレイトの定義、複数の型への実装

#### 第 15 章: ジェネリクスとトレイト境界
- **目的:** 汎用的なコードを書く
- ジェネリック関数
- ジェネリック構造体
- トレイト境界 (where 句)
- 関連型
- **比較:**
  * Python: ジェネリクス (typing.Generic)
  * Go: ジェネリクス (Go 1.18+)
  * Rust: 強力なトレイトシステムと組み合わせ
- **練習問題:** 汎用的なコンテナ、ジェネリックな検索関数

#### 第 16 章: 標準トレイト (Debug, Clone, Copy, PartialEq, Eq 等)
- **目的:** 標準トレイトを使いこなす
- Debug: デバッグ出力
- Clone: 明示的な複製
- Copy: 暗黙的な複製
- PartialEq/Eq: 等値比較
- PartialOrd/Ord: 順序比較
- Default: デフォルト値
- Display: ユーザー向け出力
- derive 属性による自動実装
- **比較:**
  * Python: __eq__, __str__, __repr__ 等
  * Go: Stringer interface 等
  * Rust: derive macro による自動実装
- **よくあるエラー:** trait の実装忘れ
- **練習問題:** カスタム型への標準トレイト実装

#### 第 17 章: スマートポインタ (Box, Rc, Arc)
- **目的:** 間接参照とメモリ管理を理解する
- Box<T>: ヒープ割り当て
- Rc<T>: 参照カウント (シングルスレッド)
- Arc<T>: アトミック RC (マルチスレッド)
- Weak<T>: 循環参照の回避
- **比較:**
  * Python: すべてがヒープ、自動 GC
  * Go: new、ポインタ、GC
  * Rust: 明示的なスマートポインタ
- **なぜ Rust はこう設計されているのか:** 柔軟なメモリ管理
- **練習問題:** 木構造、グラフ構造

#### 第 18 章: 内部可変性 (RefCell, Mutex)
- **目的:** 不変性ルールの例外を理解する
- RefCell<T>: 実行時借用チェック
- Mutex<T>: 排他制御
- RwLock<T>: 読み書きロック
- Cell<T>: 単純な内部可変性
- **比較:**
  * Python/Go: ロック、ミューテックス
  * Rust: コンパイル時 + 実行時の安全性保証
- **よくあるエラー:** already borrowed、deadlock
- **練習問題:** キャッシュの実装、共有状態の管理

---

### 第 4 部: プロジェクト管理とテスト (3 章)

#### 第 19 章: モジュールとパッケージ管理
- **目的:** 大規模プロジェクトの構成を学ぶ
- モジュールシステム (mod)
- 公開と非公開 (pub)
- use 宣言
- クレートとパッケージ
- Cargo.toml の設定
- 依存関係の管理
- ワークスペース
- **比較:**
  * Python: import、pip、requirements.txt
  * Go: package、go mod
  * Rust: mod、Cargo.toml、Cargo.lock
- **練習問題:** 複数モジュールのプロジェクト

#### 第 20 章: テストの書き方
- **目的:** 堅牢なコードを書く
- ユニットテスト (#[test])
- アサーション (assert!, assert_eq!)
- 統合テスト (tests/ ディレクトリ)
- ドキュメンテーションテスト
- テストの組織化
- モックとテストダブル
- **比較:**
  * Python: unittest、pytest
  * Go: testing、テーブル駆動テスト
  * Rust: 組み込みテストフレームワーク
- **練習問題:** 既存コードへのテスト追加

#### 第 21 章: ドキュメントとベストプラクティス
- **目的:** 保守性の高いコードを書く
- ドキュメンテーションコメント (///)
- cargo doc の使い方
- クレートのドキュメント
- エラーメッセージの設計
- コーディング規約
- Clippy によるリント
- **比較:**
  * Python: docstring、Sphinx
  * Go: godoc
  * Rust: cargo doc、rustdoc
- **練習問題:** ドキュメント付きライブラリの作成

---

### 第 5 部: 並行性と Async (3 章)

#### 第 22 章: スレッドと並行性
- **目的:** マルチスレッドプログラミングをマスターする
- スレッドの作成 (thread::spawn)
- データ競合の防止
- Arc<Mutex<T>> パターン
- チャネル (mpsc)
- スレッドプール
- **比較:**
  * Python: threading、multiprocessing、GIL
  * Go: goroutine、channel
  * Rust: OS スレッド、型システムによる安全性
- **なぜ Rust はこう設計されているのか:** データ競合のコンパイル時検出
- **よくあるエラー:** デッドロック、Send/Sync エラー
- **練習問題:** 並列計算、Producer-Consumer パターン

#### 第 23 章: Async/Await の基礎
- **目的:** 非同期プログラミングの基本を学ぶ
- async/await の仕組み
- Future trait
- Tokio ランタイム
- async fn と blocking
- 非同期ストリーム
- **比較:**
  * Python: asyncio、async/await
  * Go: goroutine で代用 (await なし)
  * Rust: ゼロコスト非同期、Future ベース
- **練習問題:** 非同期 HTTP クライアント

#### 第 24 章: 実践的な非同期プログラミング
- **目的:** 実際の非同期アプリケーションを書く
- タイムアウトと再試行
- 並行リクエスト (join!, select!)
- エラーハンドリング
- async trait の使い方
- パフォーマンスチューニング
- **比較:** Python asyncio vs Rust Tokio
- **練習問題:** Web スクレイパー、並行 API 呼び出し

---

### 第 6 部: 実践プロジェクト (4 章)

#### 第 25 章: CLI ツールの開発
- **目的:** 実用的なコマンドラインツールを作る
- clap による引数パース
- エラー処理 (anyhow)
- ファイル I/O
- 設定ファイルの読み込み (serde)
- プログレスバー (indicatif)
- カラー出力
- **プロジェクト:** ログ解析ツール、ファイル検索ツール
- **比較:**
  * Python: argparse、Click
  * Go: flag、cobra
  * Rust: clap、structopt

#### 第 26 章: Web アプリケーション (Actix/Axum)
- **目的:** Web アプリケーションを Rust で書く
- Actix-web または Axum の基本
- ルーティング
- ミドルウェア
- JSON API (serde_json)
- データベース接続 (sqlx、diesel)
- 認証・認可
- **プロジェクト:** REST API、簡単な Web サービス
- **比較:**
  * Python: Flask、FastAPI
  * Go: net/http、Gin、Echo
  * Rust: Actix-web、Axum、パフォーマンス

#### 第 27 章: データ処理とファイル I/O
- **目的:** データ処理パイプラインを作る
- CSV/JSON/XML の読み書き
- バイナリデータの扱い
- ストリーミング処理
- 並列データ処理 (rayon)
- メモリマップドファイル
- **プロジェクト:** データ ETL ツール、ログ集計
- **比較:**
  * Python: pandas、csv、json
  * Go: encoding/csv、encoding/json
  * Rust: serde、csv、パフォーマンス重視

#### 第 28 章: Python/Go コードからの移行戦略
- **目的:** 既存コードを Rust に移行する
- 移行の判断基準
- FFI (Foreign Function Interface)
- PyO3 による Python 連携
- cgo との比較
- 段階的移行の戦略
- パフォーマンス測定
- **ケーススタディ:** Python 製ツールの Rust 化
- **比較:** Python/Go vs Rust、移行の成功例

---

### 第 7 部: 発展的トピック (3 章)

#### 第 29 章: マクロの基礎
- **目的:** 宣言的マクロを理解する
- macro_rules! の基本
- パターンマッチング
- 繰り返し
- よく使うマクロ (vec!, println! 等)
- 手続き的マクロの紹介
- **比較:**
  * Python: デコレータ、メタクラス
  * Go: generate
  * Rust: 強力なマクロシステム
- **練習問題:** カスタムマクロの作成

#### 第 30 章: Unsafe コードと最適化
- **目的:** パフォーマンスの限界に挑む
- unsafe とは何か
- 生ポインタ
- unsafe 関数
- FFI (外部関数インターフェース)
- プロファイリング (perf、flamegraph)
- 最適化テクニック
- **いつ unsafe を使うべきか、使わないべきか**
- **練習問題:** パフォーマンスクリティカルな処理

#### 第 31 章: 本番環境へのデプロイ
- **目的:** Rust アプリケーションを本番運用する
- リリースビルド (cargo build --release)
- クロスコンパイル
- Docker コンテナ化
- ログとモニタリング (tracing)
- エラー追跡 (sentry 等)
- CI/CD (GitHub Actions)
- **比較:** Python/Go のデプロイ vs Rust
- **チェックリスト:** 本番環境での注意点

---

### 付録

#### 付録 A: Rust のイディオム集
- 一般的なパターンとアンチパターン
- Effective Rust 的なベストプラクティス

#### 付録 B: エラーメッセージ対応表
- よくあるコンパイルエラーと解決法
- 躓きやすいポイント集

#### 付録 C: Python/Go -> Rust 対応表
- 構文の対応表
- 標準ライブラリの対応表
- よく使うクレートの紹介

#### 付録 D: 参考資料とコミュニティ
- 公式ドキュメント
- おすすめの学習リソース
- Rust コミュニティへの参加方法

---

### 各章の共通要素

**各章には必ず以下を含める:**

1. **Python/Go ではこうやっていた**
   - 既存の知識を確認
   - 3 年目エンジニアなら知っているはずの内容

2. **Rust ではこう書く**
   - 新しい書き方を段階的に導入
   - 1 章 1 概念の原則を守る

3. **なぜ Rust はこう設計されているのか**
   - 設計思想を理解
   - トレードオフを明示

4. **実践例**
   - 実際のユースケース
   - プロジェクトで使える例

5. **よくあるエラーと対処法**
   - コンパイルエラー
   - 実行時エラー
   - 原因と解決法、予防法

6. **練習問題**
   - 基礎問題 (必須)
   - 応用問題 (チャレンジ)
   - 解答例 (GitHub で公開)

7. **この章のまとめ**
   - 重要ポイント 3-5 個
   - チェックリスト

---

### 総ページ数の見積もり

| 部 | 章数 | 想定ページ数/章 | 合計 |
|----|------|----------------|------|
| 第 0 部 | 2 章 | 15 ページ | 30 ページ |
| 第 1 部 | 6 章 | 25 ページ | 150 ページ |
| 第 2 部 | 5 章 | 25 ページ | 125 ページ |
| 第 3 部 | 5 章 | 25 ページ | 125 ページ |
| 第 4 部 | 3 章 | 20 ページ | 60 ページ |
| 第 5 部 | 3 章 | 25 ページ | 75 ページ |
| 第 6 部 | 4 章 | 30 ページ | 120 ページ |
| 第 7 部 | 3 章 | 20 ページ | 60 ページ |
| 付録 | 4 つ | - | 50 ページ |
| **合計** | **31 章** | - | **約 800 ページ** |

**想定:**
- Kindle 版: 最適化されたレイアウト
- 紙版 (POD): B5 判、2 段組

---

### 本書の特徴 (再確認)

1. **Python/Go 経験者に特化**
   - 各章で 3 言語を比較
   - 既存知識を活かす構成
   - 3 年目エンジニアが次のレベルへ

2. **包括的な内容**
   - 基礎から実践まで網羅
   - 現場で必要な要素をすべてカバー
   - プロジェクトで活躍できる知識

3. **徹底的な一貫性**
   - 第 1 部: 必ず return を明示
   - 第 15 章で慣用的な書き方へ移行
   - 用語・スタイルの統一

4. **1 章 1 概念**
   - 詰め込まない
   - 確実に理解
   - 段階的な難易度

5. **実践重視**
   - 各章に練習問題
   - 第 6 部で 4 つの実践プロジェクト
   - 現場で使えるテクニック

---

## 5. GitHub リポジトリ構成 (案)

### 5.1 リポジトリ構造

```
rust-deep-understanding/
├── README.md                    # 本の紹介、進捗状況
├── LICENSE                      # ライセンス (CC BY-NC-SA 等)
│
├── manuscript/                  # 原稿 (Markdown 形式)
│   ├── part1-basics/
│   │   ├── chapter01.md        # 第 1 章
│   │   ├── chapter02.md
│   │   └── ...
│   ├── part2-intermediate/
│   │   ├── chapter15.md
│   │   └── ...
│   ├── part3-advanced/
│   │   ├── chapter26.md
│   │   └── ...
│   └── appendix/
│       ├── setup.md            # 環境構築
│       ├── glossary.md         # 用語集
│       └── references.md       # 参考文献
│
├── code/                        # サンプルコード
│   ├── chapter01/
│   │   ├── README.md
│   │   └── examples/
│   │       ├── 01_hello.rs
│   │       └── 02_variables.rs
│   ├── chapter06/
│   │   ├── README.md
│   │   └── examples/
│   │       ├── unwrap_or_basic.rs
│   │       └── unwrap_or_http_status.rs
│   └── ...
│
├── exercises/                   # 演習問題
│   ├── chapter06/
│   │   ├── problem01.md
│   │   ├── problem02.md
│   │   └── solutions/
│   │       ├── problem01_solution.rs
│   │       └── problem02_solution.rs
│   └── ...
│
├── projects/                    # 実践プロジェクト
│   ├── chapter08-cli-tool/     # 第 8 章: 簡単な CLI ツール
│   │   ├── Cargo.toml
│   │   ├── src/
│   │   └── README.md
│   ├── chapter26-full-cli/     # 第 26 章: 本格的な CLI ツール
│   │   └── ...
│   └── chapter27-web-api/      # 第 27 章: Web アプリ
│       └── ...
│
├── comparison/                  # 他言語との比較コード
│   ├── error_handling/
│   │   ├── python_version.py
│   │   ├── go_version.go
│   │   └── rust_version.rs
│   └── ...
│
├── assets/                      # 画像・図表
│   ├── diagrams/
│   └── screenshots/
│
├── errata/                      # 正誤表
│   └── errata.md
│
├── feedback/                    # 読者フィードバック
│   ├── issues.md
│   └── suggestions.md
│
└── tools/                       # ビルドツール
    ├── build.sh                # 原稿を ePub に変換
    └── test_code.sh            # コード例のテスト
```

### 5.2 各章の執筆テンプレート

```markdown
# 第 X 章: [章タイトル]

## この章のゴール
- [習得スキル 1]
- [習得スキル 2]
- [習得スキル 3]

## 前章の復習
[前章で学んだことを簡潔に復習]

## なぜこれが必要なのか？
[動機付け: この章で学ぶ概念がなぜ必要なのか]

## 基本的な使い方

### シンプルな例
'''rust
[最もシンプルな例]
'''

[説明]

### よくある間違い
'''rust
// ・ 間違った書き方
[間違った例]
'''

**なぜ間違いか:** [理由]

'''rust
// ・ 正しい書き方
[正しい例]
'''

## 実践例

### 例 1: [実用的なシナリオ]
'''rust
[コード]
'''

[説明]

### 例 2: [別のシナリオ]
'''rust
[コード]
'''

[説明]

## 使い分けの基準

| 状況 | 使う方法 | 理由 |
|------|---------|------|
| [状況 1] | [方法 1] | [理由 1] |
| [状況 2] | [方法 2] | [理由 2] |

## よくあるエラーと対処法

### エラー 1: [エラーメッセージ]
'''
error[E0XXX]: [メッセージ]
'''

**原因:** [なぜこのエラーが出るのか]

**解決法:** [どう修正すればいいか]

**予防:** [次から気をつけること]

## 練習問題

### 問題 1: [タイトル]
[問題文]

**要件:**
- [要件 1]
- [要件 2]

**ヒント:** [ヒント]

解答は `exercises/chapterXX/problem01_solution.rs` を参照

### 問題 2: [タイトル]
[問題文]

### 問題 3: [タイトル]
[問題文]

## この章のまとめ
- [重要ポイント 1]
- [重要ポイント 2]
- [重要ポイント 3]

## チェックリスト
以下のことができるようになったか確認しましょう:
- [スキル 1]
- [スキル 2]
- [スキル 3]

## 次の章へ
次の章では「[次章のテーマ]」を学びます。
[簡単な導入]
```

### 5.3 コード例のテンプレート

**各章のコード例ディレクトリ:**

```
code/chapterXX/
├── README.md                   # この章のコード例について
├── Cargo.toml                  # 必要に応じて
└── examples/
    ├── 01_basic.rs            # 基本例
    ├── 02_intermediate.rs     # 中級例
    └── 03_advanced.rs         # 応用例
```

**コード例のコメントスタイル:**
```rust
// ============================================
// 第 6 章: unwrap_or の基本例
// ============================================

fn main() {
    // 成功ケース: Ok の中の値が返される
    let result: Result<i32, String> = Ok(200);
    let status = result.unwrap_or(0);
    println!("ステータス: {}", status);  // => 200

    // エラーケース: デフォルト値 (0) が返される
    let result: Result<i32, String> = Err("network error".to_string());
    let status = result.unwrap_or(0);
    println!("ステータス: {}", status);  // => 0

    // なぜ 0 をデフォルト値にしたのか:
    // HTTP ステータスコードは常に正の整数なので、
    // 0 は「エラーが発生した」ことを明確に示せる
}
```

---

## 6. 執筆方針・原則

### 6.1 一貫性チェックリスト

**各章の執筆時に必ずチェック:**

**コーディングスタイル:**
- `return` の書き方は統一されているか
- セミコロンの使い方は統一されているか
- 変数名の付け方は統一されているか (`result`, `value` など)
- インデントは統一されているか

**用語:**
- 同じ概念に同じ用語を使っているか
- 略称を使う場合、最初に定義しているか
- 前章と用語が一致しているか
- 用語集に追加したか

**説明レベル:**
- 各章の丁寧さが揃っているか
- 突然難しくなっていないか
- 前章の知識だけで理解できるか
- コメントの量は適切か

**無駄の排除:**
- 使わない変数を定義していないか
- 説明なしの特殊構文を使っていないか
- 複数の概念が混在していないか
- すべてのコードに意味があるか

**スタイル変更:**
- スタイル変更は専用の章で導入しているか
- なぜ変更するのか理由を説明しているか
- 新旧両方を比較しているか
- 変更のタイミングは適切か (最低 5 章以降)

---

### 6.2 執筆の鉄則

**絶対にやらないこと:**

1. **「雰囲気だけ」「おまじない」という表現**
   - これは説明の放棄
   - 読者の知性を侮辱
   - 深い理解を妨げる

2. **複数の概念を同時に導入**
   - 1 章 1 概念が鉄則
   - 例外なし

3. **説明なしの特殊構文**
   - `b'h'`, `r"raw string"`, `#[derive(...)]` など
   - 必ず専用の節で説明してから使用

4. **一貫性のないスタイル変更**
   - 変更は専用の章で
   - 理由を必ず説明
   - 新旧を比較

5. **実用性のない複雑な例**
   - 「カッコいい」より「分かりやすい」
   - シンプルさを最優先

6. **「慣れてきたら」を今紹介**
   - 「後で」なら後で
   - 最低 5-10 章は間を空ける

**必ずやること:**

1. **1 章 1 概念の徹底**
   - 欲張らない
   - 確実に理解させる
   - 豊富な練習問題

2. **なぜその概念が必要か説明**
   - 動機付けから始める
   - 前の方法の限界を示す
   - 新しい方法の利点を説明

3. **使い分けの基準を明示**
   - 比較表を使う
   - 具体的な状況を示す
   - 「いつ使うか」を明確に

4. **豊富な練習問題**
   - 各章に最低 3 問
   - 段階的な難易度
   - 実践的なシナリオ

5. **読者の疑問を先回り**
   - 「よくある質問」セクション
   - 「よくある間違い」セクション
   - エラーメッセージの意味を解説

6. **前章の復習**
   - 各章の冒頭で復習
   - 知識の定着を確認
   - 不安を解消

---

### 6.3 品質保証

**レビュー体制:**

**Phase 1: セルフレビュー**
- 一貫性チェックリストで確認
- 鉄則に違反していないか
- 無駄な要素はないか

**Phase 2: 初心者レビュー (最重要)**
- Rust 初心者 5-10 名に読んでもらう
- 「ここで混乱した」ポイントを記録
- 理解度テストを実施
- フィードバックを即座に反映

**Phase 3: 中級者レビュー**
- Rust 経験者に技術的正確性を確認
- より良い説明方法の提案
- 実践的な例の追加

**Phase 4: 最終レビュー**
- 全体の整合性チェック
- 用語の統一確認
- 一貫性の最終確認

**継続的改善:**
- 読者からのフィードバックを収集
- GitHub でイシュー管理
- 定期的なアップデート
- 正誤表の維持

---

## 7. 競合分析

### 7.1 主要な競合書籍

| 書籍名 | 対象読者 | ページ数 | 強み | 弱み |
|--------|---------|---------|------|------|
| The Rust Book | 初心者 | 500+ | 公式、無料 | 詰め込みすぎ、一貫性なし |
| Rust in Action | 中級者 | 400+ | 実践的 | 初心者には難しい |
| Programming Rust | 経験者 | 600+ | 網羅的 | 入門には向かない |
| 実践 Rust 入門 | 初心者 | 350 | 日本語 | 「雰囲気で」が多い |

### 7.2 本書の差別化ポイント

**既存書籍との比較:**

| 項目 | 既存の入門書 | 本書 |
|------|------------|------|
| **説明スタイル** | 「雰囲気で」「おまじない」 | すべてに「なぜ」を説明 |
| **概念の導入** | 複数同時 (unwrap_or + and_then + ?) | 1 章 1 概念 (unwrap_or だけ) |
| **一貫性** | バラバラ (return あり→なし→あり) | 徹底 (第 1-10 章は必ず return) |
| **練習問題** | 少ない (各章 0-1 問) | 豊富 (各章 3-5 問) |
| **エラー対処** | 不十分 (エラー文だけ) | 詳しく (原因・解決法・予防) |
| **例の質** | 複雑 (Box + b'h' + [u8] 同時) | シンプル (Box::new(5) から) |
| **特殊構文** | 説明なしで使用 | 専用の節で説明 |
| **現場での実用性** | 低い (表面的理解) | 高い (深い理解) |

### 7.3 本書の強み

1. **挫折させない設計**
   - 段階的な難易度
   - 確実な理解の積み重ね
   - 「自分でもできる」という自信
   - 躓きポイントを先回りして解消

2. **現場で使える知識**
   - 表面的な理解ではない
   - エラーに対処できる
   - 最適な方法を選べる
   - チームに教えられる

3. **長期的な価値**
   - 基礎が固まるので応用が効く
   - リファレンスとしても使える
   - チーム教育にも使える
   - 10 年後も価値がある

4. **革新的なアプローチ**
   - 既存書籍の問題を具体的に解決
   - 一貫性への徹底的なこだわり
   - 1 章 1 概念の厳格な実施
   - 「わかったかんじ」の排除

---

## 8. 執筆スケジュール

### 8.1 詳細スケジュール

| フェーズ | 期間 | 内容 | マイルストーン | GitHub タスク |
|---------|------|------|--------------|-------------|
| **Phase 0: 準備** | 2 週間 | リポジトリ構築、テンプレート作成 | リポジトリ公開 | - README 作成<br>- ディレクトリ構造<br>- Issue/PR テンプレート |
| **Phase 1: プロトタイプ** | 1 ヶ月 | 第 1-3 章執筆、β 読者募集 | サンプル章公開 | - 第 1-3 章 PR<br>- β 読者募集 Issue |
| **Phase 2: 第 1 部執筆** | 3 ヶ月 | 基礎編 (第 1-14 章) | 第 1 部完成 | - 各章 PR<br>- コード例追加<br>- 練習問題 |
| **Phase 3: 第 2 部執筆** | 3 ヶ月 | 応用編 (第 15-25 章) | 第 2 部完成 | - 同上 |
| **Phase 4: 第 3 部執筆** | 2 ヶ月 | 実践編 (第 26-30 章) | 全章完成 | - プロジェクト追加 |
| **Phase 5: レビュー** | 2 ヶ月 | 初心者テスト、技術レビュー | 改稿完了 | - Feedback Issue<br>- 修正 PR |
| **Phase 6: 編集・出版** | 1 ヶ月 | 校正、フォーマット、出版 | 書籍リリース | - Release tag<br>- PDF/ePub 生成 |
| **合計** | **12 ヶ月** | | | |

### 8.2 週次目標 (例: Phase 2 の第 6 章)

**第 1 週: 第 6 章「unwrap_or でデフォルト値」**

| 曜日 | タスク | 成果物 | GitHub アクション |
|------|--------|--------|-----------------|
| 月 | 章構成、アウトライン作成 | chapter06_outline.md | Draft PR 作成 |
| 火水 | 本文執筆 (なぜ必要か、基本的な使い方) | chapter06.md (前半) | PR 更新 |
| 木 | コード例作成、テスト | code/chapter06/examples/*.rs | コミット |
| 金 | 練習問題作成、解答作成 | exercises/chapter06/*.rs | コミット |
| 土 | よくある間違いセクション追加 | chapter06.md (完成) | PR 更新 |
| 日 | セルフレビュー、一貫性チェック | - | PR Ready for Review |

### 8.3 マイルストーン

**M1: プロトタイプ完成 (1 ヶ月後)**
- 第 1-3 章完成
- β 読者 10 名確保
- フィードバック 1 回目

**M2: 第 1 部完成 (4 ヶ月後)**
- 第 1-14 章完成
- 基礎編レビュー完了
- 一貫性確認済み

**M3: 第 2 部完成 (7 ヶ月後)**
- 第 15-25 章完成
- 応用編レビュー完了

**M4: 全章完成 (9 ヶ月後)**
- 第 26-30 章完成
- 全体の整合性チェック

**M5: 出版準備完了 (11 ヶ月後)**
- レビュー・改稿完了
- 技術レビュー完了

**M6: 出版 (12 ヶ月後)**
- Kindle 版リリース
- PDF/ePub 版リリース

---

## 9. 期待される成果

### 9.1 読者にとっての成果

**技術的成果:**
- Rust を「難しい言語」ではなく「理解できる言語」として認識
- 自信を持って Rust のコードが書ける
- エラーが出ても自分で解決できる
- 最適なエラーハンドリング方法を選択できる
- トレイトシステムを理解している
- 所有権・借用の本質を理解している

**実践的成果:**
- 現場で Rust を使ったプロジェクトに参加できる
- チームメンバーに Rust を教えられる
- 技術選定で Rust を選択する自信がある
- Rust のエコシステムを使いこなせる

**キャリア的成果:**
- Rust エンジニアとしてのキャリアパス
- 高単価案件への参加
- システムプログラミング領域への進出

### 9.2 市場にとっての成果

**Rust コミュニティへの貢献:**
- Rust 学習の新しいスタンダード
- 「Rust は難しい」という誤解の解消
- Rust 開発者の増加に貢献
- 日本語 Rust 教育リソースの充実

**産業界への貢献:**
- 企業での Rust 導入の後押し
- Rust エンジニアの不足解消
- システムプログラミング領域の活性化

### 9.3 出版社にとっての成果

**ビジネス的成果:**
- 既存書籍との明確な差別化
- 長期的に売れ続けるロングセラー候補
- 読者からの高評価・口コミによる拡散
- 技術書としてのブランド確立

**展開可能性:**
- 続編 (中級編、実践編) の展開
- オンライン講座への展開
- 企業研修コンテンツとしての販売
- 翻訳版の可能性

---

## 10. マーケティング戦略

### 10.1 プレマーケティング (執筆中)

**GitHub での公開執筆:**
- 執筆過程を公開
- コミュニティからのフィードバック
- 早期ファンの獲得
- Star/Watch 数を増やす

**技術ブログでの連載:**
- Zenn, Qiita, note 等で章の一部を公開
- 「Rust 入門書の問題点」シリーズ
- 読者を巻き込む
- SNS での拡散

**SNS での発信:**
- Twitter: 執筆進捗の共有
- LinkedIn: プロフェッショナル向け
- Reddit (r/rust): 海外コミュニティへ
- Discord/Slack: Rust コミュニティ

### 10.2 リリース時

**プラットフォーム:**
- Kindle Direct Publishing (優先)
- 技術書典
- BOOTH
- 自社サイト (GitHub Pages で)

**価格戦略:**
- 早期割引 (発売 1 週間): 20% OFF
- バンドル販売 (電子+紙)
- 学生割引: 30% OFF
- 企業向けライセンス

**プロモーション:**
- 技術カンファレンスでの発表 (RustConf, etc.)
- Podcast 出演 (Rustacean Station 等)
- YouTube での解説動画
- 無料サンプル章の配布 (第 1-3 章)

### 10.3 リリース後

**コミュニティ構築:**
- Discord/Slack コミュニティ
- 定期的な勉強会 (月 1 回)
- Q&A セッション (隔週)
- 読者同士の交流

**継続的改善:**
- 読者フィードバックの反映
- Rust バージョンアップ対応
- 無料アップデートの提供 (半年ごと)
- 追加章の執筆 (有料アップデート)

**追加コンテンツ:**
- 動画解説 (YouTube)
- スライド資料 (Speaker Deck)
- オンライン講座 (Udemy 等)
- 企業研修パッケージ

---

## 11. 著者の強み・執筆への覚悟

### 11.1 独自の視点

**実体験に基づく問題意識:**
- 既存入門書の問題点を実際に体験
- 初心者が躓くポイントを熟知
- 「なぜ理解できないのか」を言語化できる
- 本企画書で提示したような具体的な改善案を持っている

**強いこだわり:**
- 「わかったかんじ」にさせない執筆への執念
- 読者の知性を信頼する姿勢
- 一貫性への徹底的なこだわり
- 「現場で使える」ことへの強い信念

### 11.2 執筆方針

**絶対に妥協しないこと:**
1. 一貫性 (最初から最後まで)
2. 1 章 1 概念 (例外なし)
3. 深い理解 (「雰囲気で」は絶対に言わない)
4. 実用性 (無駄な例は 1 つも入れない)

**読者との約束:**
- この本を読めば、現場で Rust が書けるようになる
- エラーが出ても、自分で解決できるようになる
- 「Rust は難しい」ではなく「Rust は理解できる」と思えるようになる

---

## 12. 次のアクションプラン

### 12.1 今すぐできること (今週)

**1. GitHub リポジトリの作成**
```bash
# リポジトリ名
rust-deep-understanding

# 初期構成
├── README.md
├── manuscript/
│   └── part1-basics/
├── code/
├── exercises/
└── .gitignore
```

**2. README.md の作成**
- 本の紹介
- 執筆方針
- 進捗状況
- 貢献方法

**3. 第 1 章のプロトタイプ**
- アウトライン作成
- 最初の 1000 文字を書く
- サンプルコード 1 つ

### 12.2 今月中にやること

**1. 第 1-3 章の完成**
- 各章 10,000 文字程度
- コード例各章 3 つ
- 練習問題各章 2 つ

**2. β 読者の募集**
- Twitter/Zenn で告知
- 5-10 名の募集
- フィードバックフォームの作成

**3. フィードバックの収集と反映**
- 「混乱したポイント」の記録
- 即座に改善
- 第 2 版の公開

### 12.3 3 ヶ月後の目標
- 第 1 部 (第 1-14 章) 完成
- β 読者からのフィードバック反映済み
- コード例・練習問題すべて完備
- GitHub スター 100 以上

---

## 13. 本企画の総括

### 13.1 本書のビジョン

本書は、既存の Rust 入門書が抱える根本的な問題を解決し、**「わかったかんじ」ではなく「深い理解」**を提供します。

**3 つの革新:**
1. **徹底的な一貫性** → 安心して学べる
2. **1 章 1 概念** → 確実に理解できる
3. **深い説明** → 現場で使える

**5 つの原則:**
1. 絶対に詰め込まない
2. 「雰囲気で」と言わない
3. すべてに「なぜ」を説明
4. 無駄な要素を排除
5. 一貫性を最優先

### 13.2 最終的な目標

**本書が目指すのは:**
- 10 年後も読まれ続ける、Rust 学習の新しいスタンダード
- 「Rust は難しい」という誤解を解消する一冊
- 現場で自信を持ってコードが書ける開発者を育成
- 日本の Rust コミュニティの発展に貢献

**成功の指標:**
- 読者満足度: 4.5 以上 (Amazon, 技術書典)
- 完読率: 70% 以上
- 「現場で使えた」という声: 多数
- コミュニティでの推薦: 自然発生的な拡散
- GitHub スター: 1,000 以上

### 13.3 本企画の核心

本企画書で指摘したように、既存の Rust 入門書には多くの問題があります:
- エラーメッセージを使わない例
- 1 ページに 6 つの概念を詰め込む
- 「雰囲気だけつかんで」という説明の放棄
- 説明なしの特殊構文
- 一貫性の欠如

これらすべてを解決し、**本当に理解できる、本当に使える** Rust 入門書を作ります。

「わかったかんじ」で終わらせない。
深い理解を、確実に。
現場で、自信を持って。

**これが、本書の提供する価値です。**

---

## 付録: 問い合わせ先

**著者:** [あなたの名前]
**Email:** [メールアドレス]
**Twitter:** [@username]
**GitHub:** https://github.com/username/rust-deep-understanding

**フィードバック:**
本企画書へのご意見・ご感想をお待ちしています。
